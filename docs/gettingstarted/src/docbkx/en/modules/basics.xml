<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
      "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<section>
   <title>Basic Configuration and Usage</title>

   <para>The Microcontainer's main purpose is to allow external configuration of
      POJOs. As we have seen in
      <xref linkend="examples"/>
      , the POJOs in a Microcontainer applications are nothing special. The key element that drives
      the application is the
      <varname>jboss-beans.xml</varname>
      configuration file.
      So, in this chapter, we will look at the some of the common configurations in
      <varname>jboss-beans.xml</varname>
      .
   </para>

   <section>
      <title>Deployment</title>

      <para>The
         <varname>deployment</varname>
         element acts as a container for many beans that are deployed together.
      </para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

         &lt;!-- Deployment holds beans --&gt;
         &lt;deployment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="urn:jboss:bean-deployer bean-deployer_1_0.xsd"
         xmlns="urn:jboss:bean-deployer"&gt;

         &lt;!-- bean part of the deployment --&gt;
         &lt;bean .../&gt;

         &lt;!-- bean part of the deployment --&gt;
         &lt;bean .../&gt;

         &lt;/deployment&gt;</programlisting>
   </section>

   <section>
      <title>Bean</title>

      <para>The
         <varname>bean</varname>
         element is the main deployment component. It describes a single managed object in the runtime.
      </para>

      <programlisting>
         &lt;deployment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="urn:jboss:bean-deployer bean-deployer_1_0.xsd"
         xmlns="urn:jboss:bean-deployer">

         &lt;bean name="Simple"
         class="org.jboss.example.microcontainer.simple.SimpleBean"/>

         &lt;/deployment>
      </programlisting>

      <para>The example above from the
         <varname>simple</varname>
         example uses the default constructor of
         <varname>SimpleBean</varname>
         to create a new POJO.
      </para>

      <programlisting>
         new org.jboss.example.microcontainer.simple.SimpleBean();
      </programlisting>

      <para>It is given the name
         <varname>"Simple"</varname>
         such that it can be referenced elsewhere.
      </para>
   </section>

   <section>
      <title>Construction</title>

      <para>The example above uses the default constructor. What if you don't want to use some other constructor. The
         simplest mechanism just matches the number of parameters in the constructor. The example below is from the
         <varname>constructor</varname>
         example.
      </para>

      <programlisting>
         public class ConstructorBean
         {
         ... ...

         public ConstructorBean(int integer)
         {
         ... ...
         }
      </programlisting>

      <para>The
         <varname>jboss-beans.xml</varname>
         element for creating the POJO using the above constructor is as follows.
      </para>

      <programlisting>
         &lt;bean name="Integer"
         class="org.jboss.example.microcontainer.constructor.ConstructorBean">
         &lt;constructor>
         &lt;parameter>4&lt;/parameter>
         &lt;/constructor>
         &lt;/bean>
      </programlisting>

      <para>The microcontainer would just use the following to create the
         <varname>Integer</varname>
         named component.
      </para>

      <programlisting>
         new ConstructorBean (4);
      </programlisting>

      <para>Sometimes there are two constructors with the same number of parameters. In this case, you must specify the
         types to resolve the ambiguity.
      </para>

      <programlisting>
         public class ConstructorBean {
         public ConstructorBean(String string, int integer) {}
         public ConstructorBean(String string, long long) {}
         }
      </programlisting>

      <para>The following configuration creates a managed bean instance named
         <varname>StringLong</varname>
         using the second constructor listed above.
      </para>

      <programlisting>
         &lt;bean name="StringLong"
         class="org.jboss.example.microcontainer.constructor.ConstructorBean">
         &lt;constructor>
         &lt;parameter>a string&lt;/parameter>
         &lt;parameter class="long">10&lt;/parameter>
         &lt;/constructor>
         &lt;/bean>
      </programlisting>

      <para>Behind the scene, the Micorcontainer invokes:</para>

      <programlisting>
         new ConstructorBean ("a string", (long) 10);
      </programlisting>

      <para>Note that you only have to be explicit enough to resolve the ambiguity.</para>

   </section>

   <section>
      <title>Factories</title>

      <para>Not all classes have pubic constructors. It is often good practice to use factories when you to have a
         choice of implementation for an interface. The microcontainer includes support for the several different types
         of factory. The simplest case is a static factory class with a static factory method like the following from
         the
         <varname>factory</varname>
         example.
      </para>

      <programlisting>
         public class StaticFactory
         {
         public static FactoryCreatedBean createBean()
         {
         return new FactoryCreatedBean("StaticFactory.createBean()");
         }
         }
      </programlisting>

      <para>The bean configuration tells the microcontainer to the use the
         <varname>StaticFactory.createBean()</varname>
         static method to create an instance of
         <varname>FactoryCreatedBean</varname>
         .
      </para>

      <programlisting>
         &lt;bean name="StaticFactoryCreatedBean"
         class="org.jboss.example.microcontainer.factory.FactoryCreatedBean">
         &lt;constructor factoryMethod="createBean"
         factoryClass="org.jboss.example.microcontainer.factory.StaticFactory"/>
         &lt;/bean>
      </programlisting>

      <para>Of course, the factory class itself does not have to be static. The microcontainer can create a non-static
         factory itself as a managed object, and then use this factory object to create other bean objects. For
         instance, the
         <varname>factory</varname>
         example contains a singleton factory class example.
      </para>

      <programlisting>
         public class SingletonFactory
         {
         private static SingletonFactory singleton;

         public synchronized static SingletonFactory getInstance()
         {
         if (singleton == null)
         singleton = new SingletonFactory();
         return singleton;
         }

         public FactoryCreatedBean createBean()
         {
         return new FactoryCreatedBean("SingletonFactory.createBean()");
         }

         private SingletonFactory()
         {
         System.out.println("SingletonFactory()");
         }
         }
      </programlisting>

      <para>In the following configuration, we first create an instance of the
         <varname>SingletonFactory</varname>
         class under the name
         <varname>"SingletonFactory"</varname>
         using the
         <varname>SingletonFactory.getInstance()</varname>
         static method. Then, we use this factory object to create a
         <varname>FactoryCreatedBean</varname>
         instance under the name
         <varname>SingletonFactoryCreatedBean</varname>
         .
      </para>

      <programlisting>
         &lt;bean name="SingletonFactory"
         class="org.jboss.example.microcontainer.factory.SingletonFactory">
         &lt;constructor factoryMethod="getInstance"
         factoryClass="org.jboss.example.microcontainer.factory.SingletonFactory"/>
         &lt;/bean>

         &lt;bean name="SingletonFactoryCreatedBean"
         class="org.jboss.example.microcontainer.factory.FactoryCreatedBean">
         &lt;constructor factoryMethod="createBean">
         &lt;factory bean="SingletonFactory"/>
         &lt;/constructor>
         &lt;/bean>
      </programlisting>

      <para>Like the constructor method we mentioned before, the factory method can also take call parameters via the
         nested
         <varname>parameter</varname>
         element.
      </para>

   </section>

   <section>
      <title>Properties</title>

      <para>It is possible to create all objects using factories and constructors, however many people use the JavaBean
         or MBean convention where an object is constructed using a default constructor and then configured using
         properties or attributes (i.e., setter methods). The following class from the
         <varname>properties</varname>
         example is a JavaBean style POJO.
      </para>

      <programlisting>
         public class PropertiesBean
         {
         public PropertiesBean()
         {
         System.out.println("PropertiesBean()");
         }

         public void setTitle(String title)
         {
         System.out.println("setTitle: " + title);
         }

         public void setSubTitle(String subTitle)
         {
         System.out.println("setSubTitle: " + subTitle);
         }

         public void setLink(URL url)
         {
         System.out.println("setLink: " + url);
         }

         public void setNumber(Number number)
         {
         System.out.println("setNumber: " + number + " type=" + number.getClass().getName());
         }
         }
      </programlisting>

      <para>The configuration creates the
         <varname>PropertiesBean</varname>
         instance and then use the setter methods to set its properties.
      </para>

      <programlisting>
         &lt;bean name="PropertiesBean"
         class="org.jboss.example.microcontainer.properties.PropertiesBean">
         &lt;property name="title">JBoss Microcontainer property example&lt;/property>
         &lt;property name="subTitle">&lt;null/>&lt;/property>
         &lt;property name="link">http://www.jboss.org&lt;/property>
         &lt;property name="number" class="java.lang.Long">4&lt;/property>
         &lt;/bean>
      </programlisting>

      <para>Here we use the string representation of various objects, including the
         <varname>null</varname>
         value. They will be discussed in more detail in the next section.
      </para>

   </section>

   <section>
      <title>String Values</title>

      <para>Now, you probably noticed that we use string values to represent all kinds of objects in the
         <varname>parameter</varname>
         element for the constructors or factory methods, and in the
         <varname>property</varname>
         element for JavaBean properties.
      </para>

      <para>In the most generic case, a JavaBean
         <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/java/beans/PropertyEditor.html">PropertyEditor</ulink>
         can be used to convert a string to a specific type. JBoss already provides a large number of property editors
         for standard types. Please see the example below for the POJO class, the configuration, and the resultant
         Microcontainer action.
      </para>

      <programlisting>
         import java.beans.PropertyEditorSupport;
         public class URLEditor extends PropertyEditorSupport{
         public void setAsText(final String text){
         setValue(new URL(text));
         }
         }

         public class Example{
         public URL getLink() {}
         public void setLink(URL url) {}
         }

         &lt;bean name="Name1" class=com.acme.Example"&gt;
         &lt;property name="link"&gt;http://acme.com/index.html&lt;/property&gt;
         &lt;/bean&gt;

         Example example = new com.acme.Example();
         PropertyEditor editor = PropertyEditorManager.findEditor(URL.class);
         editor.setAsText("http://acme.com/index.html");
         example.setLink((URL)editor.getValue());
      </programlisting>

      <para>Often the property takes an interface or abstract class, but you want to pass a specific implementation or a
         subclass. That is easy. Just specify the implementation class in the
         <varname>property.class</varname>
         attribute as show below.
      </para>

      <programlisting>
         public class Example{
         public Number getNumber() {}
         public void setNumber(Number number) {}
         }

         &lt;bean name="Name1" class=com.acme.Example"&gt;
         &lt;property name="number" class="java.lang.Long"&gt;4&lt;/property&gt;
         &lt;/bean&gt;

         Example example = new com.acme.Example();
         example.setNumber(new Long(4));
      </programlisting>


      <para>There is also a more long-winded form of value that we will see later when configuring collections.</para>

      <programlisting>
         public class Example{
         public Number getNumber() {}
         public void setNumber(Number number) {}
         }

         &lt;bean name="Name1" class=com.acme.Example"&gt;
         &lt;property name="number"&gt;&lt;value class="java.lang.Long"&gt;4&lt;/value&gt;&lt;/property&gt;
         &lt;/bean&gt;

         Example example = new com.acme.Example();
         example.setNumber(new Long(4));
      </programlisting>


      <para>Finally, the
         <varname>null</varname>
         value is trivial, &lt;null/&gt;. But, it needs to differentiated from the string "null". Please see the example
         below for the usage.
      </para>

      <programlisting>
         public class Example{
         public String getTitle() {}
         public void setTitle(String string) {}
         }

         &lt;!-- Wrong --&gt;
         &lt;bean name="Name1" class=com.acme.Example"&gt;
         &lt;property name="title"&gt;null&lt;/property&gt;
         &lt;/bean&gt;

         Example example = new com.acme.Example();
         example.setTitle(new String("null"));

         &lt;!-- Correct --&gt;
         &lt;bean name="Name1" class=com.acme.Example"&gt;
         &lt;property name="title"&gt;&lt;null/&gt;&lt;/property&gt;
         &lt;/bean&gt;

         Example example = new com.acme.Example();
         example.setTitle(null);
      </programlisting>

      <para>Sometimes it is still usefull to be able to set or inject a value which can be morfed / progressed into
         needed type althogh existing type is not compatible (normally getting ClassCastException). This is mostly true
         for java.lang.Number subclasses. Let's see how <varname>progression</varname> is used on the following example.
      </para>

      <programlisting>

         &lt;bean name="FromBean" class="org.jboss.test.kernel.config.support.SimpleBean">
            &lt;property name="adouble">123.456&lt;/property>
            &lt;property name="AFloat" class="java.lang.Float">987.6543&lt;/property>
            &lt;property name="anInt">314159&lt;/property>
         &lt;/bean>

         &lt;bean name="SimpleBean" class="org.jboss.test.kernel.config.support.SimpleBean">
            &lt;property name="anint">&lt;inject bean="FromBean" property="adouble" />&lt;/property>
            &lt;property name="AShort">&lt;inject bean="FromBean" property="AFloat" />&lt;/property>
            &lt;property name="AFloat">&lt;inject bean="FromBean" property="anInt" />&lt;/property>
         &lt;/bean>

      </programlisting>

      <para>SimpleBean is a plain JavaBean, property names reflect the field type: having a<varname>double</varname>
         property name means that a field is of type double. A<varname>Float</varname> coresponds to Float type. Etc.
      </para>

      <para>You can change the progression behavior by setting System property
         <varname>org.jboss.reflect.plugins.progressionConvertor</varname>,
         putting the ProgressionConvertor's implementation fully qualified class name as value.
         By default SimpleProgressionConvertor implementation is used. Another existing implementation is
         NullProgressionConvertor, which doesn't do any actual progression.
      </para>

   </section>

   <section>
      <title>Injections</title>

      <para>Objects by themself are not very useful. They need to be linked together to form more complicated data
         structures. We have already seen one form of an injection when using factory instances above. Injections can be
         used anywhere a string value is used. All the examples that we have previously seen with strings could also be
         done with injections.
      </para>

      <para>The
         <varname>injection</varname>
         example shows how dependency injection works in JBoss Microcontainer. The
         <varname>InjectionBean</varname>
         class has a
         <varname>host</varname>
         property, which is the
         <varname>java.net.URL</varname>
         type. We will inject an URL object into the bean via the microcontainer.
      </para>

      <programlisting>
         public class InjectionBean
         {
         String name;

         public InjectionBean(String name)
         {
         this.name = name;
         System.out.println("InjectionBean() " + this);
         }

         public String toString()
         {
         return name;
         }

         public void setHost(String host)
         {
         System.out.println("setHost: " + host + " on " + this);
         }

         public void setOther(InjectionBean other)
         {
         System.out.println("setOther: " + other + " on " + this);
         }
         }
      </programlisting>

      <para>The microcontainer creates the
         <varname>URL</varname>
         object first, and then passes the
         <varname>URL</varname>
         object as a property into the
         <varname>InjectionBean1</varname>
         object when it is instantiated.
      </para>

      <programlisting>
         &lt;bean name="URL" class="java.net.URL">
         &lt;constructor>
         &lt;parameter>http://www.jboss.org/index.html&lt;/parameter>
         &lt;/constructor>
         &lt;/bean>

         &lt;bean name="InjectionBean1"
         class="org.jboss.example.microcontainer.injection.InjectionBean">
         &lt;constructor>
         &lt;parameter>InjectionBean1&lt;/parameter>
         &lt;/constructor>
         &lt;property name="host">&lt;inject bean="URL" property="host"/>&lt;/property>
         &lt;/bean>
      </programlisting>


      <para>The order of the
         <varname>bean</varname>
         elements does not matter. The microcontainer orders the beans into the correct order. For instance, in the
         above example, the
         <varname>URL</varname>
         object is always created before the
         <varname>InjectionBean1</varname>
         object since the latter is dependent on the former. But that leaves the problem of how to resolve circular
         dependencies. These can be resolved by specifying when you want the injection to occur. In the example below we
         say once
         <varname>Circular1</varname>
         is "Instantiated" (constructed) it is ok to configure it on
         <varname>Circular2</varname>
         . Normally, injections wait for the referenced bean to reach the state "Installed" (see later on life cycles).
      </para>

      <programlisting>
         &lt;bean name="Circular1"
         class="org.jboss.example.microcontainer.injection.InjectionBean">
         &lt;constructor>
         &lt;parameter>Circular1&lt;/parameter>
         &lt;/constructor>
         &lt;property name="other">&lt;inject bean="Circular2"/>&lt;/property>
         &lt;/bean>

         &lt;bean name="Circular2"
         class="org.jboss.example.microcontainer.injection.InjectionBean">
         &lt;constructor>
         &lt;parameter>Circular2&lt;/parameter>
         &lt;/constructor>
         &lt;property name="other">
         &lt;inject bean="Circular1" state="Instantiated"/>
         &lt;/property>
         &lt;/bean>
      </programlisting>

      <para>Here is the order the microcontainer instantiates those objects.</para>

      <programlisting>
         InjectionBean Circular1 = new InjectionBean ();
         InjectionBean Circular2 = new InjectionBean ();
         Circular1.setOther(Circular2); // don't wait for a fully configured Circular1
         Circular2.setOther(Circular1); // Complete the confguration of Circular2
      </programlisting>

   </section>

   <section>
      <title>Collections</title>

      <para>The
         <varname>collection</varname>
         ,
         <varname>list</varname>
         ,
         <varname>set</varname>
         and
         <varname>array</varname>
         elements are used to enclose collection of values to pass to the bean components as properties or constructor
         (factory method) parameters. The default types are:
      </para>

      <itemizedlist mark="bullet">
         <listitem>
            <para>collection: java.util.ArrayList</para>
         </listitem>
         <listitem>
            <para>list: java.util.ArrayList</para>
         </listitem>
         <listitem>
            <para>set: java.util.HashSet</para>
         </listitem>
         <listitem>
            <para>array: java.lang.Object[]</para>
         </listitem>
      </itemizedlist>

      <para>They all take the same form. So, only
         <varname>list</varname>
         is shown here in those examples. You just need to nest
         <varname>value</varname>
         elements inside the collection element to specify the contents of the collection. Please note that a
         <varname>"elementClass"</varname>
         attribute is required on the collection element, unless you specify explicit types on all the
         <varname>value</varname>
         s.
      </para>

      <para>Below is a sample configuration from the
         <varname>collections</varname>
         example. It sets a
         <varname>List</varname>
         with two elements of mixed types to the
         <varname>ObjectPrinter.print</varname>
         property on the
         <varname>PrintList</varname>
         named object.
      </para>

      <programlisting>
         &lt;bean name="PrintList"
         class="org.jboss.example.microcontainer.collections.ObjectPrinter">
         &lt;constructor>&lt;parameter>List&lt;/parameter>&lt;/constructor>
         &lt;property name="print">
         &lt;list elementClass="java.lang.String">
         &lt;value>Value of type elementClass&lt;/value>
         &lt;value class="java.lang.Integer">4&lt;/value>
         &lt;/list>
         &lt;/property>
         &lt;/bean>
      </programlisting>

      <para>It is also possible to use a
         <varname>List</varname>
         as an element inside another
         <varname>List</varname>
         . Here is an example.
      </para>

      <programlisting>
         &lt;bean name="Name1" class=com.acme.Example"&gt;
         &lt;property name="list"&gt;
         &lt;list class="java.util.LinkedList" elementClass="java.lang.String"&gt;

         &lt;value&gt;A string&lt;/value&gt; &lt;!-- uses elementClass --&gt;

         &lt;value class="java.lang.URL"&gt;http://acme.com/index.html&lt;/value&gt; &lt;!-- a URL --&gt;

         &lt;value&gt;&lt;inject bean="SomeBean"/&gt;&lt;/value&gt; &lt;!-- inject some other bean --&gt;

         &lt;value&gt; &lt;!-- a list inside a list --&gt;
         &lt;list elementClass="java.lang.String"&gt;
         &lt;value&gt;Another string&lt;/value&gt;
         &lt;/list&gt;
         &lt;/value&gt;

         &lt;/list&gt;
         &lt;/property&gt;
         &lt;/bean&gt;
      </programlisting>

      <para>Below is what happens inside the microcontainer.</para>

      <programlisting>
         Example example = new com.acme.Example();
         List list = new LinkedList();
         list.add(new String("A string"));
         list.add(new URL("http://acme.com/index.html"));
         list.add(someBean);
         List subList = new ArrayList();
         subList.add(new String("Another string"));
         list.add(subList);
         element.setList(list);
      </programlisting>

      <para>The other type of collection is a map which also covers Properties and Hashtables. The default is
         <varname>java.util.HashMap</varname>
         . The
         <varname>entry</varname>
         element inside the map differentiates each
         <varname>key</varname>
         and
         <varname>value</varname>
         pair. For maps there are two default types for the elements: the
         <varname>keyClass</varname>
         and
         <varname>valueClass</varname>
         . Below is a map sample from the
         <varname>collections</varname>
         example.
      </para>

      <programlisting>
         &lt;bean name="PrintMap"
         class="org.jboss.example.microcontainer.collections.ObjectPrinter">
         &lt;constructor>&lt;parameter>Map&lt;/parameter>&lt;/constructor>
         &lt;property name="print">
         &lt;map keyClass="java.lang.String" valueClass="java.lang.String">
         &lt;entry>
         &lt;key>Key1 of type keyClass&lt;/key>
         &lt;value>Value1 of type valueClass&lt;/value>
         &lt;/entry>
         &lt;entry>
         &lt;key>Key2 of type keyClass&lt;/key>
         &lt;value class="java.lang.Integer">4&lt;/value>
         &lt;/entry>
         &lt;entry>
         &lt;key class="java.lang.Long">4&lt;/key>
         &lt;value>Value of type valueClass&lt;/value>
         &lt;/entry>
         &lt;/map>
         &lt;/property>
         &lt;/bean>
      </programlisting>

   </section>

   <section>
      <title>Lifecycle</title>

      <para>Anybody familiar with the JBoss JMX microkernel will know about the lifecycle. The microcontainer extends
         the lifecycle concept to the managed POJOs. A POJO can have the following lifecycle states.
      </para>

      <itemizedlist mark="bullet">
         <listitem>
            <para>Not Installed: The POJO has not been described or has been uninstalled.</para>
         </listitem>
         <listitem>
            <para>Pre Install: The scoping description has been examined and classloader dependencies determined.</para>
         </listitem>
         <listitem>
            <para>Described: The POJO's bean description has been examined and dependencies determined.</para>
         </listitem>
         <listitem>
            <para>Instantiated: All the dependencies have been resolved to construct the bean, these include, the class
               exists, the constructor parameter injections can be resolved, any factory can be resolved.
            </para>
         </listitem>
         <listitem>
            <para>Configured: All the property injections can be resolved, this includes all the dependencies in any
               collections.
            </para>
         </listitem>
         <listitem>
            <para>Create: All the dependent beans have been "created", this includes any injections passed to the create
               method.
            </para>
         </listitem>
         <listitem>
            <para>Start: All the dependent beans have been "started", this includes any injections passed to the start
               method.
            </para>
         </listitem>
         <listitem>
            <para>Installed: The lifecycle is complete.</para>
         </listitem>
         <listitem>
            <para>*** ERROR ***: Some unexpected error occured, usually due to misconfiguration.</para>
         </listitem>
      </itemizedlist>

      <para>At each stage of the lifecycle, the corresponding method in the bean class is automatically called by the
         Microcontainer, so that you can programatically control how the objects behave throughout its lifecycle. For
         instance, the
         <varname>start()</varname>
         method in the bean class is called when the bean enters the
         <varname>Start</varname>
         state. Below is the
         <varname>LifecycleBean</varname>
         class from the
         <varname>lifecycle</varname>
         example.
      </para>

      <programlisting>
         public class LifecycleBean
         {
         String name;

         public LifecycleBean(String name)
         {
         this.name = name;
         System.out.println("LifecycleBean() " + this);
         }

         public void create()
         {
         System.out.println("create: " + this);
         }

         public void start()
         {
         System.out.println("start: " + this);
         }

         public void stop()
         {
         System.out.println("stop: " + this);
         }

         public void destroy()
         {
         System.out.println("destroy: " + this);
         }

         public String toString()
         {
         return name;
         }
         }
      </programlisting>

      <para>The
         <varname>depends</varname>
         element allows two beans to perform two phase startup processing like the JMX microkernel.
      </para>

      <programlisting>
         &lt;bean name="Lifecycle1"
         class="org.jboss.example.microcontainer.lifecycle.LifecycleBean">
         &lt;constructor>
         &lt;parameter>Lifecycle1&lt;/parameter>
         &lt;/constructor>
         &lt;depends>Lifecycle2&lt;/depends>
         &lt;/bean>

         &lt;bean name="Lifecycle2"
         class="org.jboss.example.microcontainer.lifecycle.LifecycleBean">
         &lt;constructor>
         &lt;parameter>Lifecycle2&lt;/parameter>
         &lt;/constructor>
         &lt;/bean>
      </programlisting>

      <para>The microcontainer resolves the dependency and starts both beans in the appropriate order. Below is the
         console output when you run the
         <varname>lifecycle</varname>
         example. It shows when various lifecycle methods are called when the bean enters those states.
      </para>

      <programlisting>
         run:
         [java] LifecycleBean() Lifecycle1
         [java] LifecycleBean() Lifecycle2
         [java] create: Lifecycle2
         [java] create: Lifecycle1
         [java] start: Lifecycle2
         [java] start: Lifecycle1
         [java] stop: Lifecycle1
         [java] stop: Lifecycle2
         [java] destroy: Lifecycle1
         [java] destroy: Lifecycle2
      </programlisting>

      <para>The
         <varname>create()</varname>
         ,
         <varname>start()</varname>
         ,
         <varname>stop()</varname>
         and
         <varname>destroy()</varname>
         methods can be overridden with parameters passed to them. Below is an example on how to override the
         <varname>create()</varname>
         method via the
         <varname>jboss-beans.xml</varname>
         configuration file.
      </para>

      <programlisting>
         public class Example{
         public void initialize(Object someObject) {}
         }

         &lt;bean name="Name1" class="com.acme.Example"&gt;
         &lt;create method="initialize"&gt;
         &lt;parameter&gt;&lt;inject bean="SomeBean"/&gt;&lt;/parameter&gt;
         &lt;/create&gt;
         &lt;/bean&gt;
      </programlisting>

      <para>They can also be ignored. See the
         <varname>jboss-beans.xml</varname>
         with ignore attribute set to true on the start element.
      </para>

      <programlisting>
         public class Example{
         public void start() {}
         }

         &lt;bean name="Name1" class="com.acme.Example"&gt;
         &lt;start ignore="true"/&gt;
         &lt;/bean&gt;
      </programlisting>

      <para>In this case Microcontainer would not
         invoke start method when passing over Start state.
      </para>
   </section>

   <section>
      <title>Installation</title>

      <para>As of 2.0.0, you can provide generic install/uninstall actions. Allowing you to dynamically setup
         repositories. Note the use of
         <varname>this</varname>
         to pass yourself as a parameter. If you exlude the bean name on the action, the operation is performed on
         yourself.
      </para>

      <programlisting>
         &lt;bean name="Name1" class="java.util.Timer"/&gt;
         &lt;bean name="Name2" ...&gt;
         &lt;install bean="Name1" method="schedule"&gt;
         &lt;parameter&gt;&lt;this/&gt;&lt;/parameter&gt;
         &lt;parameter&gt;100&lt;/parameter&gt;
         &lt;parameter&gt;10000&lt;/parameter&gt;
         &lt;/install&gt;
         &lt;uninstall method="cancel"/&gt;
         &lt;/bean&gt;

         // Install
         Name1 = new Timer();
         Name2 = ...;
         Name1.schedule(Name2, 100, 10000);

         // Uninstall
         name2.cancel();
      </programlisting>
   </section>

   <section>
      <title>ClassLoader</title>

      <para>The Microcontainer supports configuration of the classloader at either the deployment or bean level. The
         classloader element has three alternatives.
      </para>

      <programlisting>
         // deployment level - applies to all beans in the deployment
         &lt;deployment&gt;
         &lt;classloader&gt;&lt;inject bean="ClassLoaderName"/&gt;&lt;/classloader&gt;

         // bean level
         &lt;bean name="Name2" ...&gt;
         &lt;classloader&gt;&lt;inject bean="ClassLoaderName"/&gt;&lt;/classloader&gt;
         &lt;/bean&gt;

         // bean level will use any deployment level classloader
         &lt;bean name="Name2" ...&gt;
         &lt;/bean&gt;

         // bean level as null to not use any deployment level classloader
         &lt;bean name="Name2" ...&gt;
         &lt;classloader&gt;&lt;null/&gt;&lt;/classloader&gt;
         &lt;/bean&gt;
      </programlisting>
   </section>

   <section>
      <title>Alias</title>

      <para>
         TODO ... alias
      </para>

      <programlisting>
      </programlisting>

   </section>

   <section>
      <title>Demand / Supply</title>

      <para>
         There is another useful definition of loosly coupled dependency.
         Each bean can define which beans should be installed for it to move
         to certain state.
      </para>

      <programlisting>
         &lt;bean name="TM" class="com.acme.SomeSingleton1"&gt;
         &lt;property name="host">http://www.jboss.org&lt;/property>
         &lt;/bean&gt;

         &lt;bean name="SM" class="com.acme.AnotherSingleton"&gt;
         &lt;property name="treadSize">10&lt;/property>
         &lt;/bean&gt;

         &lt;bean name="Name2" class="com.acme.Example"&gt;
         &lt;property name="threadPool">&lt;inject bean="pool"/>&lt;/property>
         &lt;demand state="Start">TM&lt;/demand&gt;
         &lt;demand state="Configure">SM&lt;/demand&gt;
         &lt;/bean&gt;

         // Example class
         public class Example{

         public void start() {
         SomeSingleton tm = ...; // should be there!
         }

         public void setThreadPool(ThreadPool pool) {
         AnotherSingleton config = ...; // should be there
         pool.setThreadSize(config.getThreadSize());
         }

         }

      </programlisting>

      <para>
         On the other hand each bean can also provide additional information
         what it supplies, apart from it self. The actual supply doesn't need to be
         binded to Microcontainer in any way.
         More about this feature with the actual example.
      </para>

      <programlisting>
         public class FooBarBinder extends JndiBinder {

         public void start() {
         FooBar foobar = new FooBar();
         bindToJndi("fbName", foobar);
         }

         }

         public class FooBarConsumer {
         public FooBarConsumer() {
         FooBar foobar = ...; // get it from jndi. should be there
         }
         }

         &lt;bean name="provider" class="com.acme.FooBarBinder"&gt;
         &lt;supply>foobar&lt;/property>
         &lt;/bean&gt;

         &lt;bean name="consumer" class="com.acme.FooBarConsumer"&gt;
         &lt;demand state="Instantiate">foobar&lt;/>;
         &lt;/bean&gt;
      </programlisting>
   </section>

   <section>
      <title>Contextual awareness</title>

      <para>
         With existing annoyance of using huge amounts of xml to sometimes wire up
         trivial beans, IoC containers provide a simpler solution called autowiring.
         Beans, specially singletons, can often be wired with a simple class type knowledge.
         But with huge systems you should use this feature with care, since it can easly get broken
         with addition of another bean that would satisfy contextual dependency.
         Existing 2.0.0 version supports three ways of autowiring:
         <itemizedlist spacing="compact">
            <listitem>
               <para>full bean autowiring</para>
            </listitem>
            <listitem>
               <para>property / parameter injection</para>
            </listitem>
            <listitem>
               <para>callback injection</para>
            </listitem>
         </itemizedlist>
      </para>

      <para>
         TODO for bean autowiring.
      </para>

      <programlisting>
         &lt;bean name="autowired" class="com.acme.Example" autowire="true"&gt;
         &lt;/bean&gt;
      </programlisting>

      <para>
         When doing a propery / parameter injection of some existing bean, you can omit the bean attibute, meaning that
         Microcontainer will do the injection based on the information from the property / parameter class type.
         If no such information is available, exception will be thrown. If no such bean is eventually available, you can define
         the behavior after validation. For Strict option the deployment will fail, for Callback see the callback injection below.
         There is also a way of doing contextual injection based on property name. Property name will be matched against
         newly wired bean's name.
      </para>

      <programlisting>
         &lt;bean name="propInj" class="com.acme.ThreadPoolImpl"/&gt;

         &lt;bean name="propInj" class="com.acme.Example"&gt;
         &lt;property name="threadPool">&lt;inject/>&lt;/property>
         &lt;/bean&gt;

         &lt;bean name="paramInj" class="com.acme.Example"&gt;
         &lt;constructor>
         &lt;parameter name="threadPool">&lt;inject/>&lt;/parameter>
         &lt;/constructor>
         &lt;/bean&gt;

         public class Example {
         protected ThreadPool pool;
         public Example() {}
         public Example(ThreadPool pool) {
         this.pool = pool;
         }
         public void setThreadPool(ThreadPool pool) {
         this.pool = pool;
         }
         }
      </programlisting>

      <para>
         Sometimes it is useful to be notified of certain beans being installed / uninstalled by
         inspecting their class type. In Microcontainer we call this callbacks.
         You can define which methods should be used for callback resolution on a particular bean. Usually method
         name is sufficient, in the case of having multiple methods with the same name, you can narrow down the
         exact method by specifying class type to use for contextual lookup.
      </para>

      <programlisting>
         &lt;bean name="editorHolder" class="com.acme.Example"&gt;
         &lt;incallback method="addEditor" />
         &lt;uncallback method="removeEditor" />
         &lt;/bean&gt;

         &lt;bean name="fbEditor" class="com.acme.FooEditor"/&gt;

         public class Example {
         protected Set&lt;Editor> editors = new HashSet&lt;Editor>();
         public Example() {}
         public void addEditor(Editor editor) {
         editors.add(editor);
         }
         public void removeEditor(Editor editor) {
         editors.remove(editor);
         }
         }
      </programlisting>

      <para>
         We can do the same callback injection on a property.
         And there is also an interesting feature available, though it will be probabaly rarely used.
         You can define a Cardinality as a condition when that actual dependency is satisfied and injection
         can take place.
         The following examples shows how we need at least 2 Editor instances to satisfy callback dependency.
      </para>

      <programlisting>
         &lt;bean name="editorHolder" class="com.acme.Example"&gt;
         &lt;incallback property="editors" cardinality="2..n" />
         &lt;uncallback property="editors" />
         &lt;/bean&gt;

         &lt;bean name="fbEditor" class="com.acme.FooEditor"/&gt;
         &lt;bean name="xyzEditor" class="com.acme.XYZEditor"/&gt;

         public class Example {
         protected Set&lt;Editor> editors;
         public Example() {}
         public void setEditors(Set&lt;Editor> editors) {
         this.editors = editors;
         }
         }
      </programlisting>

      <para>While using callbacks on the Collection subclasses, currently only basic Collection subinterfaces
         are supported: List, Set and Queue. See BasicCollectionCallbackItemFactory for more details.
         But you can change the Collection callback behaviour by providing your own CollectionCallbackItemFactory.
         You do this by setting System property <varname>org.jboss.dependency.collectionCallbackItemFactory</varname>
         and putting CollectionCallbackItemFactory implementation fully qualified class name as a value.
      </para>

   </section>

</section>