<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % RH-ENTITIES SYSTEM "Common_Config/rh-entities.ent">
]>
<book>
  <bookinfo>
    <title>JBoss Microcontainer 2.0.0</title>
    <subtitle>User Guide</subtitle>
    <issuenum>2.0</issuenum>
    <productnumber>2</productnumber>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Author_Group.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Legal_Notice.xml"/>
  </bookinfo>
  <preface>
    <title>What this Book Covers</title>
    <para>This book aims to help you become familiar with  JBoss Microcontainer if you are new to the technology. Part 1 is Getting Started (with multiple chapters), Chapter 2 is Deploying, part 3 is adding behaviour. Don&apos;t change examples mid-way through a chapter. </para>
  </preface>
  <part>
    <title>Getting Started</title>
    <chapter id="overview">
      <title>Introduction</title>
      <para>The Java  platform has traditionally been distributed  in 3 editions, each  providing a different type of runtime environment: </para>
      <itemizedlist>
        <listitem>
          <para>Java ME (Micro Edition) - Mobile or other embedded devices</para>
        </listitem>
        <listitem>
          <para>Java SE (Standard Edition) - Desktop machines or servers (typically running 2-tier applications)</para>
        </listitem>
        <listitem>
          <para>Java EE (Enterprise Edition) - Servers (typically running 3-tier applications)</para>
        </listitem>
      </itemizedlist>
      <para>Each environment aims to provide a base level of functionality on top of which  developers can add their own code to create applications. For example Java SE provides networking and security libraries together with graphical user interface toolkits to facilitate the development of desktop   and simple client-server applications. Java EE takes this a stage further by adding a number of &apos;enterprise&apos;  services such as transactions, messaging, and persistence that allow much more robust and scalable &apos;enterprise&apos; applications to be developed.  These services are  typically combined together inside a JEE application server to provide a standard runtime environment for enterprise applications,  however it is often the case that we do not need to use them all.</para>
      <para>Having unused services in your  environment is undesirable as  they can take  up valuable resources such as CPU and memory. They can also clutter up the environment with unecessary configuration files which complicates maintenance and causes confusion.   It would  therefore be good if there was a  controlled way to remove them without breaking any dependencies they might have. Similarly there are often occasions when  applications need services that aren&apos;t provided by  JEE  so  it would be good if there was a  controlled way to add them, again  making sure that any dependencies are first satisfied.</para>
      <para>JBoss Microcontainer aims to provide  these capabilities by allowing services, created using Plain Old Java Objects (POJOs), to be deployed into a standard Java SE runtime environment in a controlled manner to create a customized environment  for your applications. Dependencies between services are fully managed by the microcontainer to ensure that new services cannot be deployed until services they depend on have first been deployed. Likewise undeploying a service causes all dependent services to first be undeployed to maintain the integrity of the system. </para>
      <para>Deploying services in this way, on top of a Java SE environment,   is exactly how we have created the latest version of JBoss Application Server  (JBoss AS 5.0)   which provides a standard Java EE environment. If you need additional services then you can simply deploy these on top of Java EE to provide the functionality you need. This even applies when using the microcontainer in different  Java EE environments such as Glassfish since you can plug in different classloading models  during the service deployment phase.</para>
      <para>Since  JBoss Microcontainer is very lightweight and deals with POJOs it can also be used to deploy services into a Java ME runtime environment. This opens us new possibilities for mobile applications that can now take advantage of  enterprise services without requiring a full JEE application server. </para>
      <para>In common with other lightweight containers JBoss Microcontainer uses  dependency injection to wire individual POJOs together to create services.  Configuration is performed using either XML or annotations depending on where the information is best located. Finally unit testing is made extremely simple thanks to a helper class that extends JUnit to setup the test environment, allowing you to access  POJOs and services from your test methods using just a few lines of code.</para>
    </chapter>
    <chapter>
      <title>Download and Installing</title>
      <para>To download  JBoss Microcontainer 2.0.0   go to http://labs.jboss.com/jbossmc/downloads and click on the corresponding link.</para>
      <note>
        <para>The distribution is available in a number of different packaging formats offering varying levels of compression; tar.gz, tar.bz2 or zip. Simply pick whichever one you have decompression utilities for (e.g. WinZIP on Windows can decompress zip files) and click on the link  to download it to your machine.</para>
      </note>
      <para> Installation is performed  by decompressing and unpacking the downloaded file into a directory on your machine, for example using WinZIP or gzip. The contents of the distribution are as follows:</para>
      <para>Diagram here....</para>
    </chapter>
    <chapter>
      <title>Building services</title>
      <para><emphasis role="bold">
          <emphasis role="underline">POJOs</emphasis>
        </emphasis></para>
      <para>The term POJO is an acronym for Plain Old Java Object and was first coined while Rebecca Parsons, Josh MacKenzie, and Martin Fowler were preparing for a talk at a conference in September 2000. It describes the practice of encoding  business logic in regular java objects instead of components such as EJB 2.1 Entity Beans.  The benefit of this approach is that you&apos;re not required to implement any special interfaces. This not only keeps your code simple but allows it to be used in a wider variety of environments and makes it   easy to unit test.</para>
      <para><emphasis role="bold">Definition:</emphasis> <emphasis role="italic">A POJO declares business methods, which define behaviour, and properties, which represent state. Some properties represent associations to other POJOs.</emphasis></para>
      <para>For experienced developers this should sound  familiar as it mimicks almost exactly the proposals set out in the JavaBeans specification. JavaBeans describes a component model for User Interface development emphasizing simplicity and standardized naming conventions for property accessor methods. The idea was that this would allow automatic discovery of an object&apos;s properties so that an instance could easily be created and populated with state at runtime.  The main use case was creating  and configuring visual user interface components such as text boxes,  buttons, and tables from within an integrated development environment (IDE).</para>
      <para><emphasis role="bold">Definition:</emphasis> <emphasis role="italic">A Java Bean is a reusable software component that can be manipulated visually in a builder tool.</emphasis></para>
      <para> Importantly a Java Bean is not required to inherit from any particular base class or interface. Also while Java Beans are  primarily targeted at builder tools they are entirely usable by human programmers.</para>
      <para>Strictly speaking a Java Bean should include support for events and persistence but in many cases developers choose not to implement these features and simply follow the standardized naming conventions for property accessor methods; i.e. get and set. This &apos;lightweight&apos; form of Java Bean is commonly referred to as just a &apos;bean&apos; and is semantically equivalent to a POJO.</para>
      <para>The terms POJO and bean are therefore interchangeable and you will encounter both in the microcontainer documentation and configuration files.</para>
      <para><emphasis role="bold">
          <emphasis role="underline">Services</emphasis>
        </emphasis></para>
      <para>The word &apos;service&apos;  has many definitions in the English language  but in the context of developing Java applications it is helpful to define it as follows:</para>
      <orderedlist>
        <listitem>
          <para>A service  should perform  work that is useful to multiple   clients, thereby preventing each client from having to perform the work themselves.</para>
        </listitem>
        <listitem>
          <para>A service should have a name that  clients  can lookup at runtime to gain access. This provides a standard way to access different kinds of services and  removes the need for clients to explicitly create services  before they can be used.   </para>
        </listitem>
        <listitem>
          <para>Internal changes to a service should not affect any clients.  In practice this means that clients should  access a service using a well defined interface so that the service implementation can be changed without having to recompile any clients.  </para>
        </listitem>
      </orderedlist>
      <para>Using this definition  we can now answer some simple questions:</para>
      <para>Q) Is a POJO a service?</para>
      <para>A) No, because although it performs work that is useful to multiple clients you cannot access it using a name. Clients have to create a POJO themselves either directly using the <code>new</code> operator or indirectly using a factory. </para>
      <para>Q) Does a  class have to implement an interface in order  to provide a &apos;well-defined&apos; interface?</para>
      <para>A) Not necessarily. Providing that we don&apos;t change the public method signatures of the class then we can always change its implementation without needing to recompile our client. The  &apos;well-defined&apos; interface in this respect is composed from  the public method signatures.</para>
      <note>
        <para>Implementing an  interface is  only necessary  if we want to allow a client to <emphasis role="bold">choose</emphasis> between <emphasis role="bold">alternative implementations</emphasis>. i.e. if the client is compiled against an interface then we can provide as many different implementations of the interface as we like without having to recompile the client.</para>
      </note>
      <para>What then must we do in order to create a service using a POJO? The answer is to provide a registry that allows us to register a reference to the POJO  instance with a name. Clients can then lookup the POJO reference using the name at runtime and use it to perform work. The POJO class is not required to implement an interface unless it is important that the client can choose between alternative implementations. </para>
      <para>JBoss Microcontainer provides such a registry in order that we can  deploy our POJO  services into a runtime environment such as Java SE and look them up from within our applications.</para>
      <para>Since robust implementations of Java EE services  are already available from  JBoss.org and other communities, it is common for companies to focus on creating more &apos;business-oriented&apos; services. For this reason we shall look at creating, configuring and testing a simple Human Resources service that can be used in a wide-variety of companies.</para>
      <section>
        <title>Creating POJOs</title>
        <para/>
      </section>
      <section>
        <title>Wiring POJOs together </title>
        <para>Mention that because all the beans have names, they are by definition services. The fact is that we use a registry for both internal wiring and service registration. So it may be that within the registry there are a large number of beans but you will typically only use a small number of these as the service entry points.</para>
      </section>
      <section>
        <title>Configuring a service</title>
      </section>
      <section>
        <title>Testing a service</title>
      </section>
      <section>
        <title>Packaging a service</title>
      </section>
    </chapter>
    <chapter>
      <title>Using services </title>
      <section>
        <title>Deploying a service</title>
        <para>I need to mention deploying a packaged service vs deploying an unpackaged service.</para>
      </section>
      <section>
        <title>Using the kernel registry</title>
        <para>This is equivalent to how you access beans using Spring.</para>
      </section>
      <section>
        <title>Using the kernel bus</title>
        <para>This provides the decoupling we need so that we can swap the service at runtime.</para>
      </section>
      <section>
        <title>Redeploying a service</title>
        <para>I need to show here how you can alter the jboss-beans.xml file in the unpackaged service and redeploy the service.</para>
      </section>
      <section>
        <title>Classloading</title>
        <para>I can show how we can remove the ./deploy/humanResourcesService.jar from the classpath and then deploy the jboss-beans.xml file directly in the unpackaged service. We can then configure the &lt;classloader&gt; element of the deployment to point to the classes directory since they won&apos;t be available on the Application classpath anymore. We can even move the util package to another directory and show how we can set up a &lt;classloader&gt; element at the bean level.</para>
      </section>
    </chapter>
    <chapter>
      <title>Adding behaviour through AOP</title>
      <para>Give examples as follows: Annotation in the class (JDK way), Annotation in XML, plain pointcut expression. The advice is an Audit advice.</para>
      <para>Follow this with an example that shows how we can declare the AuditAspect as a bean within MC and have a dependency between it and the AuditService class. This means that the AuditAspect will not be deployed until the Audit.jar in is the classpath. This then means that the HRManager service also cannot start since it depends on the AuditAspect.</para>
      <para>Start chapters with an introduction paragraph. This helps people to learn if they need to read on. Start each section with &apos;Imagine...&apos;. This catches peoples attention. If you intro simething then you need a summary at the end (ideally in a different way). Don&apos;t have one section like 1.2.1, always have a least 2 i.e. 1.2.1 and 1.2.2. Make the chapters and sections balanced. i.e. width ways and length ways. The outer chapters and sections always contain less information than the inner sections. They basically wrap the main content. When you write seques then you need to say what&apos;s going to happen without saying what&apos;s going to happen.</para>
    </chapter>
    <chapter>
      <title>Advanced deployment</title>
      <section>
        <title>Aspectized Deployers </title>
        <para>Give example of using aspectized bean deployer and show how it&apos;s the same.</para>
      </section>
      <section>
        <title>Changing the package structure</title>
        <para>Give an example where we move the jboss-beans.xml file out of the META-INF directory and change the location of the classes.</para>
      </section>
      <section>
        <title>Changing the XML file format</title>
        <para>Give an example of changing the jboss-beans.xml file for a jboss-beans.properties file.</para>
      </section>
      <section>
        <title>Changing the classloading strategy</title>
      </section>
      <section>
        <title>Adding a deployment stage</title>
      </section>
    </chapter>
  </part>
  <part>
    <title>POJO Development</title>
  </part>
  <part>
    <title>AOP Development</title>
  </part>
  <part>
    <title>Extending the Microcontainer</title>
    <chapter>
      <title>Guice Extensions </title>
    </chapter>
    <chapter>
      <title>OSGi Extensions</title>
    </chapter>
    <chapter>
      <title>Drools Extensions</title>
    </chapter>
    <chapter>
      <title>jBPM Extensions</title>
    </chapter>
  </part>
  <part>
    <title>Integrating the Microcontainer</title>
    <chapter>
      <title>JBoss AS</title>
      <section>
        <title>Classloading</title>
        <para>Explain that the default classloading goes to the unified repository.</para>
      </section>
      <section>
        <title>Java EE Deployers</title>
      </section>
      <section>
        <title>Backwards compatibility with MBeans</title>
      </section>
      <section>
        <title>Managing POJOs</title>
      </section>
    </chapter>
  </part>
  <appendix>
    <title>Additional Resources</title>
    <section>
      <title>Wiki</title>
    </section>
    <section>
      <title>Forums</title>
    </section>
  </appendix>
</book>
