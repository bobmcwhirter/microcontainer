<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % RH-ENTITIES SYSTEM "Common_Config/rh-entities.ent">
]>
<book>
  <bookinfo>
    <title>JBoss Microcontainer 2.0.0</title>
    <subtitle>User Guide</subtitle>
    <issuenum>2.0</issuenum>
    <productnumber>2</productnumber>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Author_Group.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Legal_Notice.xml"/>
  </bookinfo>
  <preface>
    <title>What this Book Covers</title>
    <para>This book aims to help you become familiar with  JBoss Microcontainer in order that you can use it to develop your own services or applications.</para>
    <para>Part I &apos;Getting Started&apos; introduces  the technology and explains how it relates to Java development in general. It then goes on to cover a complete use-case so that you can quickly see how the microcontainer may typically be used in real-life.</para>
    <para>Part II &apos;POJO Development&apos; takes a look at the various methods you can use  to construct POJOs and wire them together using injections together with   other features.</para>
    <para>Part III &apos;AOP Development&apos; goes on to look at how you can add behaviour to your POJOs using Aspects and covers the various ways this can be done.</para>
    <para> Part IV &apos;Extending the Microcontainer&apos; shows how you can write your own extensions by creating new dependencies and gives some examples of how this has already been done.</para>
    <para>Part V &apos;Integrating the Microcontainer&apos; covers how the microcontainer is used in JBoss AS 5 as the integration technology for the various services and core infrastructure. We also look at how legacy services, developed using MBeans, remain compatible with the new microcontainer and see how it is possible to manage POJO services at runtime.</para>
  </preface>
  <part>
    <title>Getting Started</title>
    <chapter id="overview">
      <title>Introduction</title>
      <para>The Java  platform has traditionally been distributed  in 3 editions, each  providing a different type of runtime environment: </para>
      <itemizedlist>
        <listitem>
          <para>Java ME (Micro Edition) - Mobile or other embedded devices</para>
        </listitem>
        <listitem>
          <para>Java SE (Standard Edition) - Desktop machines or servers (typically running 2-tier applications)</para>
        </listitem>
        <listitem>
          <para>Java EE (Enterprise Edition) - Servers (typically running 3-tier applications)</para>
        </listitem>
      </itemizedlist>
      <para>Each environment aims to provide a base level of functionality on top of which  developers can add their own code to create applications. For example Java SE provides networking and security libraries together with graphical user interface toolkits to facilitate the development of desktop   and simple client-server applications. Java EE takes this a stage further by adding a number of &apos;enterprise&apos;  services such as transactions, messaging, and persistence that allow much more robust and scalable &apos;enterprise&apos; applications to be developed.  These services are  typically combined together inside a JEE application server to provide a standard runtime environment for enterprise applications,  however they are not always  all used.</para>
      <para>Having unused services in your  environment is undesirable as  they can take  up valuable resources such as CPU and memory. They can also clutter up the environment with unecessary configuration files,  complicating maintenance and   adding unecessary complexity.   It would   be better if there was a  controlled way to remove such services without breaking any dependencies they might have. Similarly there are often occasions when  applications need services that aren&apos;t provided by  JEE  so  it would be better if there was a  controlled way to add them, again  making sure that any dependencies were first satisfied.</para>
      <para>JBoss Microcontainer aims to provide  these capabilities by allowing services, created using Plain Old Java Objects (POJOs), to be deployed into a standard Java SE runtime environment in a controlled manner to create a customized environment  for your applications. Dependencies between services are fully managed by the microcontainer to ensure that new services cannot be deployed until services they depend on have first been deployed. Likewise undeploying a service causes all dependent services to first be undeployed in order  to maintain the integrity of the system. </para>
      <para>Deploying services in this way, on top of a Java SE environment,   is exactly how we have created the latest version of JBoss Application Server  (JBoss AS 5.0)   which provides a standard Java EE environment. If you need additional services then you can simply deploy these on top of Java EE to provide the functionality you need. This even applies when using the microcontainer in different  Java EE environments such as Glassfish since you can plug in different classloading models  during the service deployment phase.</para>
      <para>Since  JBoss Microcontainer is very lightweight and deals with POJOs it can also be used to deploy services into a Java ME runtime environment. This opens us new possibilities for mobile applications that can now take advantage of  enterprise services without requiring a full JEE application server. </para>
      <para>In common with other lightweight containers JBoss Microcontainer uses  dependency injection to wire individual POJOs together to create services.  Configuration is performed using either XML or annotations depending on where the information is best located. Finally unit testing is made extremely simple thanks to a helper class that extends JUnit to setup the test environment, allowing you to access  POJOs and services from your test methods using just a few lines of code.</para>
    </chapter>
    <chapter>
      <title>Download and Installing</title>
      <para>JBoss Microcontainer 2.0.0 is currently only available as a beta release via Maven2. This means that you need to install and configure Maven before you can begin development. Once this is done then you can create a maven project that depends on the JBoss Microcontainer JARs in order to download and install them into your local maven repository. You can then create an assembly for your final application in order to package the relevant JARs into a distributable format.</para>
      <para>The examples created for this User Guide use Maven2 to achieve exactly this so it is highly recommended that you download these first and take a look at how they work:</para>
      <para>http://labs.jboss.com/jbossmc/downloads</para>
      <note>
        <para>To build and run the examples you first need to install and configure Maven 2.0.7 available from http://maven.apache.org/</para>
      </note>
      <para>Installation is performed by downloading and unzipping the  maven-2.0.7-bin.zip file to a convenient location on your local disk. Configuration then consists of adding $MAVEN_HOME/bin to your path and adding the following profile to your ~/.m2/settings.xml file:</para>
      <para><programlisting>&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jboss.repository&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;          
          &lt;name&gt;!jboss.repository.off&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
          &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
          &lt;id&gt;repository.jboss.org&lt;/id&gt;
          &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;repository.jboss.org&lt;/id&gt;
          &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
          &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;</programlisting></para>
      <para>This profile informs maven of the two JBoss repositories (snapshots and releases) that are needed to download the JBoss Microcontainer and dependant JARs.</para>
      <para>Once you have configured Maven and downloaded the examples then you can go to one of the following directories in the examples/User_Guide directory and enter <code>mvn install</code> to perform a build:</para>
      <para/>
      <itemizedlist>
        <listitem>
          <para>gettingStarted -  projects for creating and using a service together with AOP</para>
        </listitem>
        <listitem>
          <para>pojoDevelopment -  examples of creating and configuring POJOs using XML and Annotations</para>
        </listitem>
        <listitem>
          <para>aopDevelopment - examples of using AOP to add behaviour to POJOs</para>
        </listitem>
        <listitem>
          <para>extending - examples of how we have created various extensions to the core microcontainer by creating new dependencies</para>
        </listitem>
        <listitem>
          <para>integrating - examples of how the microcontainer forms the basis of JBoss AS 5 and how you can deploy MBean services alongside POJO services for backwards compatibility</para>
        </listitem>
      </itemizedlist>
      <para>Instructions on how to run the individual examples can be found in the relevant parts of this guide.</para>
    </chapter>
    <chapter>
      <title>Building services</title>
      <para><emphasis role="bold">
          <emphasis role="underline">POJOs</emphasis>
        </emphasis></para>
      <para>The term POJO is an acronym for Plain Old Java Object and was first coined while Rebecca Parsons, Josh MacKenzie, and Martin Fowler were preparing for a talk at a conference in September 2000. It describes the practice of encoding  business logic in regular java objects instead of components such as EJB 2.1 Entity Beans.  The benefit of this approach is that you&apos;re not required to implement any special interfaces. This not only keeps your code simple but allows it to be used in a wider variety of environments and makes it   easy to unit test.</para>
      <para><emphasis role="bold">Definition:</emphasis> <emphasis role="italic">A POJO declares business methods, which define behaviour, and properties, which represent state. Some properties represent associations to other POJOs.</emphasis></para>
      <para>For experienced developers this should sound  familiar as it mimicks almost exactly the proposals set out in the JavaBeans specification. JavaBeans describes a component model for User Interface development emphasizing simplicity and standardized naming conventions for property accessor methods. The idea was that this would allow automatic discovery of an object&apos;s properties so that an instance could easily be created and populated with state at runtime.  The main use case was creating  and configuring visual user interface components such as text boxes,  buttons, and tables from within an integrated development environment (IDE).</para>
      <para><emphasis role="bold">Definition:</emphasis> <emphasis role="italic">A Java Bean is a reusable software component that can be manipulated visually in a builder tool.</emphasis></para>
      <para> Importantly a Java Bean is not required to inherit from any particular base class or interface. Also while Java Beans are  primarily targeted at builder tools they are entirely usable by human programmers with conventional text editors.</para>
      <para>Strictly speaking a Java Bean should include support for events and persistence but in many cases developers choose not to implement these features and simply follow the standardized naming conventions for property accessor methods; i.e. get and set. This &apos;lightweight&apos; form of Java Bean is commonly referred to as simply a &apos;bean&apos; and is semantically equivalent to a POJO.</para>
      <para>The terms POJO and bean are therefore interchangeable and you will encounter both in the microcontainer documentation and configuration files.</para>
      <para><emphasis role="bold">
          <emphasis role="underline">Services</emphasis>
        </emphasis></para>
      <para>The word &apos;service&apos;  has many definitions in the English language  but in the context of developing Java applications it is helpful to define it as follows:</para>
      <orderedlist>
        <listitem>
          <para>A service  should perform  work that is useful to multiple   clients, thereby preventing each client from having to perform the work themselves.</para>
        </listitem>
        <listitem>
          <para>A service should have a name that  clients  can lookup at runtime to gain access. This provides a standard way to access different kinds of services and  removes the need for clients to explicitly create services  before they can be used.   </para>
        </listitem>
        <listitem>
          <para>Internal changes to a service should not affect any clients.  In practice this means that clients should  access a service using a well defined interface so that the service implementation can be changed without having to recompile any clients.  </para>
        </listitem>
      </orderedlist>
      <para>Using this definition  we can now answer some simple questions:</para>
      <para>Q) Is a POJO a service?</para>
      <para>A) No, because although it performs work that is useful to multiple clients you cannot access it using a name. Clients have to create a POJO themselves either directly using the <code>new</code> operator or indirectly using a factory. </para>
      <para>Q) Does a  class have to implement an interface in order  to provide a &apos;well-defined&apos; interface?</para>
      <para>A) Not necessarily. Providing that we don&apos;t remove fields or methods from a class, or restrict access to them, then  we can always change  its implementation without needing to recompile the client. See the following extract from the Java Language Specification for more details:</para>
      <para>http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html#44524</para>
      <para>The  &apos;well-defined&apos; interface in this respect is composed from  the original class&apos;s fields and method signatures together with their access modifiers.</para>
      <note>
        <para>Implementing an  interface is  only necessary  if we want to allow a client to <emphasis role="bold">choose</emphasis> between <emphasis role="bold">alternative implementations</emphasis>. i.e. if the client is compiled against an interface then we can provide as many different implementations of the interface as we like without having to recompile the client.</para>
      </note>
      <para>What then must we do in order to create a service using a POJO? The answer is to provide a naming mechanism that allows us to register a reference to the POJO  instance with a name. Clients can then lookup the POJO reference using the name at runtime and use it to perform work. The POJO class is not required to implement an interface unless it is important that the client can choose between alternative implementations. </para>
      <para>JBoss Microcontainer provides such a naming mechanism in order that we can  deploy our POJO  services into a runtime environment such as Java SE and look them up from within our applications.</para>
      <para>Since robust implementations of Java EE services  are already available from  JBoss.org and other communities, it is common for companies to focus on creating more &apos;business-oriented&apos; services. For this reason we shall look at creating, configuring and testing a simple Human Resources service that could potentially be used  in a wide-variety of companies.</para>
      <section>
        <title>Creating POJOs</title>
        <para>The example that relates to this section can be found in the <code>examples/User_Guide/gettingStarted/humanResourcesService</code> directory. The directory layout, as with all of the examples for this User Guide,  follows the <ulink url="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">Maven Standard Directory Layout</ulink>.</para>
        <para><programlisting>humanResourcesService/pom.xml
                     /src/main/java
                         /test/java
                         /test/resources</programlisting></para>
        <para>Java source files are located in packages beneath the src/main/java directory:</para>
        <para><programlisting>org/jboss/example/service/Address.java
                         /Employee.java
                         /HRManager.java

org/jboss/example/service/util/SalaryStrategy.java
                              /AgeBasedSalaryStrategy.java
                              /LocationBasedSalaryStrategy.java</programlisting></para>
        <para>As you can see from looking at the source code, each of these classes represents a simple POJO that doesn&apos;t implement any special interfaces. The most important class  is the HRManager as this represents the service entry point and therefore provides all of the public methods that clients will call.</para>
        <para/>
        <itemizedlist>
          <listitem>
            <para>addEmployee(Employee employee)</para>
          </listitem>
          <listitem>
            <para>getEmployees()</para>
          </listitem>
          <listitem>
            <para>getEmployee(String firstName, String lastName)</para>
          </listitem>
          <listitem>
            <para>removeEmployee(Employee employee)</para>
          </listitem>
          <listitem>
            <para>getSalary(Employee employee)</para>
          </listitem>
          <listitem>
            <para>setSalary(Employee employee, Integer newSalary)</para>
          </listitem>
          <listitem>
            <para>isHiringFreeze()</para>
          </listitem>
          <listitem>
            <para>setHiringFreeze(boolean hiringFreeze)</para>
          </listitem>
          <listitem>
            <para>getSalaryStrategy()</para>
          </listitem>
          <listitem>
            <para>setSalaryStrategy(SalaryStrategy strategy)</para>
          </listitem>
        </itemizedlist>
        <para>The Human Resources Service is therefore composed of the above 6 classes which work together to allow a list of employees, together with details of their addresses and salaries, to be maintained by an HR Manger. In addition it is possible to configure the service so that different salary strategies are followed by the manager. The use of such strategies places minimum and maximum limits on the salaries that can be awarded to employees depending on various rules.</para>
        <para>To compile the source code you simply need to enter <code>mvn compile</code> from the <code>humanResourcesService/</code> directory. This will create a new directory  called <code>target/classes</code>  containing the compiled code. To clean up the humanResourcesService project and remove the <code>target</code> directory simply enter <code>mvn clean</code>. </para>
        <para>Now that we  have compiled our POJO classes we  need to determine how to create instances of them. This is done by creating an XML deployment descriptor  that contains a list of beans representing individual instances. Each bean is given a name so that the instance can be looked up at runtime by clients.</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

   &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;/&gt;
      
&lt;/deployment&gt;</programlisting>
        <para>Here we have declared that we want to create an instance of the HRManager class and register it with the name &apos;HRService&apos;. </para>
      </section>
      <section>
        <title>Wiring POJOs together </title>
        <para>So far we have seen how to  create POJOs and declare instances of them together with names in the XML deployment descriptor. However, individual POJO instances  can only provide relatively simple behaviour. Things really get interesting when we combine POJOs together to perform more complex tasks. In our example we know that we can choose  a number of different salary strategies for the HRManager to use so how do we go about wiring the POJOs together?</para>
        <para>The answer is to use the XML deployment descriptor again as follows:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

   &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
     &lt;property name=&quot;salaryStrategy&quot;&gt;&lt;inject bean=&quot;AgeBasedSalary&quot;/&gt;&lt;/property&gt;
   &lt;/bean&gt;

   &lt;bean name=&quot;AgeBasedSalary&quot;
         class=&quot;org.jboss.example.service.util.AgeBasedSalaryStrategy&quot;/&gt;
       
&lt;/deployment&gt;</programlisting>
        <para>We first need to create an instance of our chosen salary strategy by including an additional &lt;bean&gt; element. Here we have chosen the AgeBasedSalaryStrategy. Next we need to inject a reference to this bean into the instance of HRManager created using the HRService bean. Injection is possible here as the HRManager class contains a <code>setSalaryStrategy(SalaryStrategy strategy)</code> method. Behind the scenes JBoss Microcontainer will call this method on the newly created HRManager instance and pass in a reference to the AgeBasedSalaryStrategy instance.</para>
        <para>In other words the XML deployment descriptor causes the same sequence of events to occur as if you had written the following code:</para>
        <programlisting>HRManager hrService = new HRManager();
AgeBasedSalaryStrategy ageBasedSalary = new AgeBasedSalaryStrategy();
hrService.setSalaryStrategy(ageBasedSalary);</programlisting>
        <para>In addition to performing injection via property setter methods JBoss Microcontainer can also perform injection via constructor parameters if necessary. For more details please see the &apos;Injection&apos; chapter in Part II &apos;POJO Development&apos;. </para>
        <note>
          <para>Although we can create instances of our classes using the &lt;bean&gt; element in the deployment descriptor it is not always appropriate to do so. For example we do not need to create instances of the Employee and Address classes since these will be created by the client. As such they remain part of the service but are not mentioned in the deployment descriptor. </para>
          <para>Also note that it is possible to define multiple beans within a deployment descriptor providing that each has a unique name. These names are required in order to perform injection as shown above.  This does not mean to say however that all of these beans represent services. While a service could be implemented using a single bean it is most often the case that multiple beans are used together as in our example. In these cases there is usually one bean that represents the service entry point containing the public methods intended for the clients to call. In our example this is the HRService bean. As such there is nothing in the XML deployment descriptor  to say which beans represent a service or indeed which bean if any is the service entry point. Care must therefore be taken when creating deployment descriptors to ensure that sufficient comments are included to describe what the beans are used for. Alternatively a naming convention such as ending  each bean name that represents a service entry point  with &apos;Service&apos;, i.e. HRService can be used instead.</para>
        </note>
      </section>
      <section>
        <title>Configuring a service</title>
        <para>Injecting references between POJO instances is one way of configuring a service however we can also inject values into POJO properties. The following deployment descriptor shows how we can configure the HRManager instance to have a hiring freeze and the AgeBasedSalaryStrategy to have new minimum and maximum salary values:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

   &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
     &lt;property name=&quot;hiringFreeze&quot;&gt;false&lt;/property&gt;
     &lt;property name=&quot;salaryStrategy&quot;&gt;&lt;inject bean=&quot;AgeBasedSalary&quot;/&gt;&lt;/property&gt;
   &lt;/bean&gt;

   &lt;bean name=&quot;AgeBasedSalary&quot; class=&quot;org.jboss.example.service.util.AgeBasedSalaryStrategy&quot;&gt;
     &lt;property name=&quot;minSalary&quot;&gt;1000&lt;/property&gt;
     &lt;property name=&quot;maxSalary&quot;&gt;80000&lt;/property&gt;
   &lt;/bean&gt;
       
&lt;/deployment&gt;</programlisting>
        <para>As with wiring POJOs together the classes need to have public setter methods for the relevant properties so that values can be injected in. For example the HRManager class has a <code>setHiringFreeze(boolean hiringFreeze)</code> method and the AgeBasedSalaryStrategy class has <code>setMinSalary(int minSalary)</code> and <code>setMaxSalary(int maxSalary)</code> methods.</para>
        <para>The values in the deployment descriptor are converted from strings into the relevant types (boolean, integer etc...) by JavaBean <ulink url="http://java.sun.com/j2se/1.5.0/docs/api/java/beans/PropertyEditor.html">PropertyEditors</ulink>. A large number of these  are provided by default for standard types but you can easily create your own if necessary. See the Properties chapter in Part II &apos;POJO Development&apos; for more details.</para>
      </section>
      <section>
        <title>Testing a service</title>
      </section>
      <section>
        <title>Packaging a service</title>
      </section>
    </chapter>
    <chapter>
      <title>Using services </title>
      <section>
        <title>Deploying a service</title>
        <para>I need to mention deploying a packaged service vs deploying an unpackaged service.</para>
      </section>
      <section>
        <title>Using the kernel controller</title>
        <para>This is equivalent to how you access beans using Spring.</para>
      </section>
      <section>
        <title>Using the kernel bus</title>
        <para>This provides the decoupling we need so that we can swap the service at runtime.</para>
      </section>
      <section>
        <title>Redeploying a service</title>
        <para>I need to show here how you can alter the jboss-beans.xml file in the unpackaged service and redeploy the service.</para>
      </section>
      <section>
        <title>Classloading</title>
        <para>I can show how we can remove the ./deploy/humanResourcesService.jar from the classpath and then deploy the jboss-beans.xml file directly in the unpackaged service. We can then configure the &lt;classloader&gt; element of the deployment to point to the classes directory since they won&apos;t be available on the Application classpath anymore. We can even move the util package to another directory and show how we can set up a &lt;classloader&gt; element at the bean level.</para>
      </section>
    </chapter>
    <chapter>
      <title>Adding behaviour through AOP</title>
      <para>Give examples as follows: Annotation in the class (JDK way), Annotation in XML, plain pointcut expression. The advice is an Audit advice.</para>
      <para>Follow this with an example that shows how we can declare the AuditAspect as a bean within MC and have a dependency between it and the AuditService class. This means that the AuditAspect will not be deployed until the Audit.jar in is the classpath. This then means that the HRManager service also cannot start since it depends on the AuditAspect.</para>
      <para>Start chapters with an introduction paragraph. This helps people to learn if they need to read on. Start each section with &apos;Imagine...&apos;. This catches peoples attention. If you intro simething then you need a summary at the end (ideally in a different way). Don&apos;t have one section like 1.2.1, always have a least 2 i.e. 1.2.1 and 1.2.2. Make the chapters and sections balanced. i.e. width ways and length ways. The outer chapters and sections always contain less information than the inner sections. They basically wrap the main content. When you write seques then you need to say what&apos;s going to happen without saying what&apos;s going to happen.</para>
    </chapter>
    <chapter>
      <title>Advanced deployment</title>
      <section>
        <title>Aspectized Deployers </title>
        <para>Give example of using aspectized bean deployer and show how it&apos;s the same.</para>
      </section>
      <section>
        <title>Changing the package structure</title>
        <para>Give an example where we move the jboss-beans.xml file out of the META-INF directory and change the location of the classes.</para>
      </section>
      <section>
        <title>Changing the XML file format</title>
        <para>Give an example of changing the jboss-beans.xml file for a jboss-beans.properties file.</para>
      </section>
      <section>
        <title>Changing the classloading strategy</title>
      </section>
      <section>
        <title>Adding a deployment stage</title>
      </section>
    </chapter>
  </part>
  <part>
    <title>POJO Development</title>
  </part>
  <part>
    <title>AOP Development</title>
  </part>
  <part>
    <title>Extending the Microcontainer</title>
    <chapter>
      <title>Guice Extensions </title>
    </chapter>
    <chapter>
      <title>OSGi Extensions</title>
    </chapter>
    <chapter>
      <title>Drools Extensions</title>
    </chapter>
    <chapter>
      <title>jBPM Extensions</title>
    </chapter>
  </part>
  <part>
    <title>Integrating the Microcontainer</title>
    <chapter>
      <title>JBoss AS</title>
      <section>
        <title>Classloading</title>
        <para>Explain that the default classloading goes to the unified repository.</para>
      </section>
      <section>
        <title>Java EE Deployers</title>
      </section>
      <section>
        <title>MBean Compatibility</title>
      </section>
      <section>
        <title>Managing POJOs</title>
      </section>
    </chapter>
  </part>
  <appendix>
    <title>Additional Resources</title>
    <section>
      <title>Wiki</title>
    </section>
    <section>
      <title>Forums</title>
    </section>
  </appendix>
</book>
