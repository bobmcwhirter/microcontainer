<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % RH-ENTITIES SYSTEM "Common_Config/rh-entities.ent">
]>
<book>
  <bookinfo>
    <title>JBoss Microcontainer 2.0.0</title>
    <subtitle>User Guide</subtitle>
    <issuenum>2.0</issuenum>
    <productnumber>2</productnumber>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Author_Group.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Legal_Notice.xml"/>
  </bookinfo>
  <preface>
    <title>What this Book Covers</title>
    <para>This book aims to help you become familiar with  JBoss Microcontainer in order that you can use it to develop your own services or applications.</para>
    <para>Part I &apos;Getting Started&apos; introduces  the technology and explains how it relates to Java development in general. It then goes on to cover a complete use-case so that you can quickly see how the microcontainer works in real-life.</para>
    <para>Part II &apos;POJO Development&apos; takes a look at the various methods you can use  to construct POJOs and wire them together using injections together with   other features.</para>
    <para>Part III &apos;AOP Development&apos; goes on to look at how you can add behaviour to your POJOs using Aspects and covers the various ways this can be done.</para>
    <para> Part IV &apos;Extending the Microcontainer&apos; shows how you can write your own extensions by creating new dependencies and gives some examples of how this has already been done.</para>
    <para>Part V &apos;Integrating the Microcontainer&apos; covers how the microcontainer is used in JBoss AS 5 as the integration technology for the various services and core infrastructure. We also look at how legacy services, developed using MBeans, remain compatible with the new microcontainer and see how it is possible to manage POJO services at runtime.</para>
  </preface>
  <part>
    <title>Getting Started</title>
    <chapter id="overview">
      <title>Introduction</title>
      <para>The Java  platform has traditionally been distributed  in 3 editions, each  providing a different type of runtime environment: </para>
      <itemizedlist>
        <listitem>
          <para>Java ME (Micro Edition) - Mobile or other embedded devices</para>
        </listitem>
        <listitem>
          <para>Java SE (Standard Edition) - Desktop machines or servers (typically running 2-tier applications)</para>
        </listitem>
        <listitem>
          <para>Java EE (Enterprise Edition) - Servers (typically running 3-tier applications)</para>
        </listitem>
      </itemizedlist>
      <para>Each environment aims to provide a base level of functionality on top of which  developers can add their own code to create applications. For example Java SE provides networking and security libraries together with graphical user interface toolkits to facilitate the development of desktop   and simple client-server applications. Java EE takes this a stage further by adding a number of &apos;enterprise  services&apos; such as transactions, messaging, and persistence that allow much more robust and scalable &apos;enterprise applications&apos; to be developed.  These services are  typically combined together inside a JEE application server in order to provide a standard runtime environment for enterprise applications but it is often the case that some are never used.</para>
      <para>Services that are never used  are undesirable as they can  take  up valuable resources such as CPU and memory resulting in lower performance. They may also clutter up the environment with redundant configuration files,  complicating maintenance and   adding unnecessary complexity.   Given these drawbacks it would   be better if there was a   way to create a custom runtime environment containing only those services  that were needed. You would then be able to create your own custom &apos;Java Edition&apos; tailored to your requirements.</para>
      <para>JBoss Microcontainer aims to provide  these capabilities by allowing services, created using Plain Old Java Objects (POJOs), to be deployed into a standard Java SE runtime environment in a controlled manner to create a customized  environment  for your applications. Dependencies are fully managed to ensure that new services cannot be deployed until services they depend on have first been deployed. Where it makes sense to do so you can even redeploy services at runtime providing that you access them via the microcontainer bus. Undeploying a service  causes all dependent services to be undeployed first in order  to maintain the integrity of the system. </para>
      <para>JBoss Application Server   5.0 uses the microcontainer to integrate enterprise services together with a Servlet/JSP container, EJB container, deployers and management utilities in order to     provide a standard Java EE environment. If you need additional services then you can simply deploy these on top of Java EE to provide the functionality you need. Likewise you are free to remove any services that you don&apos;t need simply by changing the  configuration. You can even use the microcontainer to do this in other   environments such as GlassFish and Tomcat since you can plug in different classloading models  during the service deployment phase.</para>
      <para>Since  JBoss Microcontainer is very lightweight and deals with POJOs it can also be used to deploy services into a Java ME runtime environment. This opens up new possibilities for mobile applications that can now take advantage of  enterprise services without requiring a full JEE application server. </para>
      <para>In common with other lightweight containers JBoss Microcontainer uses  dependency injection to wire individual POJOs together to create services.  Configuration is performed using either XML or annotations depending on where the information is best located. Finally unit testing is made extremely simple thanks to a helper class that extends JUnit to setup the test environment, allowing you to access  POJOs and services from your test methods using just a few lines of code.</para>
    </chapter>
    <chapter>
      <title>Download and Installing</title>
      <para>JBoss Microcontainer 2.0.0 is currently only available as a beta release via Maven2. This means that you need to install and configure Maven before you can begin development. Once this is done then you can create a maven project that depends on the JBoss Microcontainer JARs in order to download and install them into your local maven repository. You can then create an assembly for your final application in order to package the relevant JARs into a distributable format.</para>
      <para>The examples created for this User Guide use Maven2 to achieve exactly this so it is highly recommended that you <ulink url="http://labs.jboss.com/file-access/default/members/jbossmc/downloads/userGuide-examples-13112007.zip">download</ulink> these first and take a look at how they work.</para>
      <note>
        <para>To build and run the examples you first need to install and configure Maven 2.0.7 available from <ulink url="http://maven.apache.org/">http://maven.apache.org/</ulink></para>
        <para>Installation is performed by downloading and unzipping the  maven-2.0.7-bin.zip file to a convenient location on your local disk. Configuration  consists of adding $MAVEN_HOME/bin to your path and adding the following profile to your ~/.m2/settings.xml file:</para>
        <para><programlisting>&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jboss.repository&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;          
          &lt;name&gt;!jboss.repository.off&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
          &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
          &lt;id&gt;repository.jboss.org&lt;/id&gt;
          &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;repository.jboss.org&lt;/id&gt;
          &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
          &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;</programlisting></para>
        <para>This profile informs maven of the two JBoss repositories (snapshots and releases) that are needed to download the JBoss Microcontainer and dependant JARs.</para>
      </note>
      <para>Once you have configured Maven and downloaded the examples then you can go to one of the following subdirectories in the <code>examples/User_Guide</code> directory and enter <code>mvn install</code> to perform a build:</para>
      <itemizedlist>
        <listitem>
          <para>gettingStarted -  projects for creating and using a service together with AOP</para>
        </listitem>
        <listitem>
          <para>pojoDevelopment -  examples of creating and configuring POJOs using XML and annotations</para>
        </listitem>
        <listitem>
          <para>aopDevelopment - examples of using AOP to add behaviour to POJOs</para>
        </listitem>
        <listitem>
          <para>extending - examples of how we  created various extensions to the microcontainer by creating new dependencies</para>
        </listitem>
        <listitem>
          <para>integrating - examples of how JBoss Microcontainer forms the basis of JBoss AS 5 and how you can deploy MBean services alongside POJO services for backwards compatibility</para>
        </listitem>
      </itemizedlist>
      <para>Instructions on how to run the individual examples can be found in the corresponding parts of this guide.</para>
    </chapter>
    <chapter>
      <title>Building services</title>
      <para>Before we talk about building services using POJOs it is necessary to define what we mean by these terms.</para>
      <para><emphasis role="bold">
          <emphasis role="underline">POJOs</emphasis>
        </emphasis></para>
      <para>The term POJO is an acronym for Plain Old Java Object and was first coined while Rebecca Parsons, Josh MacKenzie, and Martin Fowler were preparing for a talk at a conference in September 2000. It describes the practice of encoding  business logic in regular java objects instead of components such as EJB 2.1 Entity Beans.  The benefit of this approach is that you&apos;re not required to implement any special interfaces. This not only keeps your code simple but allows it to be used in a wider variety of environments and makes it   easy to unit test.</para>
      <para><emphasis role="bold">Definition:</emphasis> <emphasis role="italic">A POJO declares business methods, which define behaviour, and properties, which represent state. Some properties represent associations to other POJOs.</emphasis></para>
      <para>For experienced developers this should sound  familiar as it mimicks almost exactly the proposals set out in the JavaBeans specification. JavaBeans describes a component model for User Interface development emphasizing simplicity and standardized naming conventions for property accessor methods. The idea was that this would allow automatic discovery of an object&apos;s properties so that an instance could easily be created and populated with state at runtime.  The main use case was creating  and configuring visual user interface components such as text boxes,  buttons, and tables from within an integrated development environment (IDE).</para>
      <para><emphasis role="bold">Definition:</emphasis> <emphasis role="italic">A Java Bean is a reusable software component that can be manipulated visually in a builder tool.</emphasis></para>
      <para> Importantly a Java Bean is not required to inherit from any particular base class or interface. Also while Java Beans are  primarily targeted at builder tools they are entirely usable by programmers with conventional text editors.</para>
      <para>Strictly speaking a Java Bean should include support for events and persistence but in many cases developers choose not to implement these features and simply follow the standardized naming conventions for property accessor methods; i.e. get and set. This &apos;lightweight&apos; form of Java Bean is commonly referred to as simply a &apos;bean&apos; and is semantically equivalent to a POJO.</para>
      <para>The terms POJO and bean are therefore interchangeable and you will encounter both in the microcontainer documentation and configuration files.</para>
      <para><emphasis role="bold">
          <emphasis role="underline">Services</emphasis>
        </emphasis></para>
      <para>The word &apos;service&apos;  has many definitions in the English language  but in the context of developing Java applications it is helpful to define it as follows:</para>
      <orderedlist>
        <listitem>
          <para>A service  should perform  work that is useful to multiple   clients, thereby preventing each client from having to perform the work themselves.</para>
        </listitem>
        <listitem>
          <para>A service should have a name that  clients  can lookup at runtime to gain access. This provides a standard way to access different kinds of services and  removes the need for clients to explicitly create them  before they can be used.   </para>
        </listitem>
        <listitem>
          <para>Internal changes to a service should not affect any clients.  In practice this means that clients should  access a service using a well defined interface so that the  implementation can be changed without having to recompile any clients.  </para>
        </listitem>
      </orderedlist>
      <para>Using this definition  we can now answer some simple questions:</para>
      <para>Q) Is a POJO a service?</para>
      <para>A) No, because although it performs work that is useful to multiple clients you cannot access it using a name. Clients have to create a POJO themselves either directly using the <code>new</code> operator or indirectly using a factory. </para>
      <para>Q) Does a  class have to implement an interface in order  to provide a &apos;well-defined&apos; interface?</para>
      <para>A) Not necessarily. Providing that we don&apos;t remove fields or methods from a class, or restrict access to them,  we can always change  its implementation without needing to recompile the client. See the  section entitled <ulink url="http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html#44524">Resolution of Symbolic References</ulink> from the Java Language Specification for more details.</para>
      <para>The  &apos;well-defined&apos; interface in this respect is composed from  the original class&apos;s fields and methods together with their access modifiers.</para>
      <note>
        <para>Implementing an  interface is  only necessary  if we want to allow a client to <emphasis role="bold">choose</emphasis> between <emphasis role="bold">alternative implementations</emphasis>. i.e. if the client is compiled against an interface then we can provide as many different implementations of the interface as we like without having to recompile the client. This is because the interface ensures that the method signatures do not change.</para>
      </note>
      <para>What then must we do in order to create a service using a POJO? The answer is to provide a naming mechanism that allows us to register a reference to the POJO  instance with a name. Clients can then lookup the POJO reference using the name at runtime and use it to perform work. The POJO class is not required to implement an interface unless it is important that the client can choose between alternative implementations. </para>
      <para>JBoss Microcontainer provides such a naming mechanism in the form of a Controller so that we can  deploy our POJO  services into a runtime environment such as Java SE and look them up from within our applications.</para>
      <para>Since robust implementations of Java EE services  are already available from  JBoss.org and other communities, it is common for companies to focus on creating more &apos;business-oriented&apos; services. For this reason we shall look at creating, configuring and testing a simple Human Resources service that could potentially be used  by a number of different applications.</para>
      <section>
        <title>Creating POJOs</title>
        <para>The example that relates to this section can be found in the <code>examples/User_Guide/gettingStarted/humanResourcesService</code> directory. The directory layout, as with all of the examples for the User Guide,  follows the <ulink url="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">Maven Standard Directory Layout</ulink>.</para>
        <para><programlisting>humanResourcesService/pom.xml
                     /src/main/java
                         /test/java
                         /test/resources</programlisting></para>
        <para>Java source files are located in packages beneath the src/main/java directory:</para>
        <para><programlisting>org/jboss/example/service/Address.java
                         /Employee.java
                         /HRManager.java

org/jboss/example/service/util/SalaryStrategy.java
                              /AgeBasedSalaryStrategy.java
                              /LocationBasedSalaryStrategy.java</programlisting></para>
        <para>Each of these classes represents a simple POJO that doesn&apos;t implement any special interfaces. The most important class is HRManager as this represents the service entry point  providing all of the public methods that clients will call.</para>
        <itemizedlist>
          <listitem>
            <para>addEmployee(Employee employee)</para>
          </listitem>
          <listitem>
            <para>removeEmployee(Employee employee)</para>
          </listitem>
          <listitem>
            <para>getEmployee(String firstName, String lastName)</para>
          </listitem>
          <listitem>
            <para>getEmployees()</para>
          </listitem>
          <listitem>
            <para>getSalary(Employee employee)</para>
          </listitem>
          <listitem>
            <para>setSalary(Employee employee, Integer newSalary)</para>
          </listitem>
          <listitem>
            <para>isHiringFreeze()</para>
          </listitem>
          <listitem>
            <para>setHiringFreeze(boolean hiringFreeze)</para>
          </listitem>
          <listitem>
            <para>getSalaryStrategy()</para>
          </listitem>
          <listitem>
            <para>setSalaryStrategy(SalaryStrategy strategy)</para>
          </listitem>
        </itemizedlist>
        <para>The Human Resources Service is therefore composed of a handful of classes which work together to allow a list of employees, together with details of their addresses and salaries, to be maintained by an HRManger. Thanks to the SalaryStrategy interface it is possible to configure the HRManager so that different salary strategy implementations are used. These place minimum and maximum limits on the salaries that can be awarded to employees depending on various rules.</para>
        <para>To compile the source code you simply need to enter <code>mvn compile</code> from the <code>humanResourcesService/</code> directory. This will create a new directory  called <code>target/classes</code>  containing the compiled code. To clean up the project and remove the <code>target</code> directory simply enter <code>mvn clean</code>. </para>
        <para>Now that we  have compiled our classes we  need to create instances of them. This is done by creating an XML deployment descriptor  that contains a list of beans representing individual instances. Each bean is given a name so that the instance can be looked up at runtime by clients.</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

   &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;/&gt;
      
&lt;/deployment&gt;</programlisting>
        <para>Here we have declared that we want to create an instance of the HRManager class and register it with the name HRService. This file is  passed to  an XML deployer associated with the microcontainer at runtime to perform the actual deployment and instantiate the beans.</para>
      </section>
      <section>
        <title>Wiring POJOs together </title>
        <para>So far we have seen how to  create POJOs and declare instances of them together with names in an XML deployment descriptor. However, individual POJO instances  can only provide relatively simple behaviour. Things really get interesting when we combine POJOs together to perform more complex tasks. In our example we know that we can choose different salary strategy implementations for the HRManager so how do we go about wiring the POJOs together?</para>
        <para>The answer is to use the XML deployment descriptor again as follows:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

   &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
     &lt;property name=&quot;salaryStrategy&quot;&gt;<emphasis>&lt;inject bean=&quot;AgeBasedSalary&quot;/&gt;</emphasis>&lt;/property&gt;
   &lt;/bean&gt;

   &lt;bean name=&quot;AgeBasedSalary&quot;
         class=&quot;org.jboss.example.service.util.AgeBasedSalaryStrategy&quot;/&gt;
       
&lt;/deployment&gt;</programlisting>
        <para>We first need to create an instance of our chosen salary strategy implementation by including an additional &lt;bean&gt; element. Here we have chosen the AgeBasedSalaryStrategy. Next we need to inject a reference to this bean into the instance of HRManager created using the HRService bean. Injection is possible  as the HRManager class contains a <code>setSalaryStrategy(SalaryStrategy strategy)</code> method. Behind the scenes JBoss Microcontainer will call this method on the newly created HRManager instance and pass in a reference to the AgeBasedSalaryStrategy instance.</para>
        <para>In other words the XML deployment descriptor causes the same sequence of events to occur as if you had written the following code:</para>
        <programlisting>HRManager hrService = new HRManager();
AgeBasedSalaryStrategy ageBasedSalary = new AgeBasedSalaryStrategy();
hrService.setSalaryStrategy(ageBasedSalary);</programlisting>
        <para>In addition to performing injection via property setter methods JBoss Microcontainer can also perform injection via constructor parameters if necessary. For more details please see the &apos;Injection&apos; chapter in Part II &apos;POJO Development&apos;. </para>
        <note>
          <para>Although we can create instances of classes using the &lt;bean&gt; element in the deployment descriptor it is not always appropriate to do so. For example we do not need to create instances of the Employee and Address classes since these will be created by the client in response to input from the user. As such they remain part of the service but are not mentioned in the deployment descriptor. </para>
        </note>
        <note>
          <para>Also note that it is possible to define multiple beans within a deployment descriptor providing that each has a unique name. The names are required in order to perform injection as shown above.  However this does not mean to say  that all of the beans represent services. While a service could be implemented using a single bean it is most often the case that multiple beans are used together as in our example. In these cases there is usually one bean that represents the service entry point containing the public methods intended for the clients to call. In our example this is the HRService bean. Notice that there is nothing in the XML deployment descriptor  to say which beans represent a service or indeed which bean if any is the service entry point (a service may run autonomously in which case it is its own client). Care must therefore be taken when creating deployment descriptors to ensure that sufficient comments are included to describe what the beans are used for. Alternatively a naming convention such as ending  each bean name that represents a service entry point  with &apos;Service&apos; can be used instead, e.g. HRService.</para>
        </note>
      </section>
      <section>
        <title>Configuring a service</title>
        <para>Injecting references between POJO instances is one way of configuring a service however we can also inject values into POJO properties. The following deployment descriptor shows how we can configure the HRManager instance to have a hiring freeze and the AgeBasedSalaryStrategy to have new minimum and maximum salary values:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

   &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
     <emphasis>&lt;property name=&quot;hiringFreeze&quot;&gt;false&lt;/property&gt;</emphasis>
     &lt;property name=&quot;salaryStrategy&quot;&gt;&lt;inject bean=&quot;AgeBasedSalary&quot;/&gt;&lt;/property&gt;
   &lt;/bean&gt;

   &lt;bean name=&quot;AgeBasedSalary&quot; class=&quot;org.jboss.example.service.util.AgeBasedSalaryStrategy&quot;&gt;
     <emphasis>&lt;property name=&quot;minSalary&quot;&gt;1000&lt;/property&gt; &lt;property name=&quot;maxSalary&quot;&gt;80000&lt;/property&gt;</emphasis>
   &lt;/bean&gt;
       
&lt;/deployment&gt;</programlisting>
        <para>As with wiring POJOs together the classes need to have public setter methods for the relevant properties so that values can be injected. For example the HRManager class has a <code>setHiringFreeze(boolean hiringFreeze)</code> method and the AgeBasedSalaryStrategy class has <code>setMinSalary(int minSalary)</code> and <code>setMaxSalary(int maxSalary)</code> methods.</para>
        <para>The values in the deployment descriptor are converted from strings into the relevant types (boolean, int etc...) by JavaBean <ulink url="http://java.sun.com/j2se/1.5.0/docs/api/java/beans/PropertyEditor.html">PropertyEditors</ulink>. A large number of these  are provided by default for standard types but you can easily create your own if necessary. See the Properties chapter in Part II &apos;POJO Development&apos; for more details.</para>
      </section>
      <section>
        <title>Testing a service</title>
        <para>We should now have a good idea about how to create POJOs and configure them using an XML deployment descriptor so how do we go about testing them? Thankfully JBoss Microcontainer makes it extremely easy to unit test individual POJOs as well as POJOs that are wired together through the use of a MicrocontainerTest class.</para>
        <para>The org.jboss.test.kernel.junit.MicrocontainerTest class inherits from junit.framework.TestCase and as such it sets up each test by bootstrapping JBoss Microcontainer and adding a BasicXMLDeployer. It then looks on the classpath for an XML deployment descriptor with the same name as the test class ending in .xml and residing in a directory structure representing the class&apos;s package name. Any beans found in this file are deployed and can then be accessed using a convenience method called <code>getBean(String name)</code>. </para>
        <para>You can see examples of these deployment descriptors in the src/test/resources directory:</para>
        <programlisting>org/jboss/example/service/HRManagerTestCase.xml
                         /HRManagerAgeBasedTestCase.xml
                         /HRManagerLocationBasedTestCase.xml

org/jboss/example/service/util/AgeBasedSalaryTestCase.xml
                              /LocationBasedSalaryTestCase.xml</programlisting>
        <para>The  test   code is located in the src/test/java directory:</para>
        <programlisting>org/jboss/example/service/HRManagerTestCase.java
                         /HRManagerAgeBasedTestCase.xml
                         /HRManagerLocationBasedTestCase.xml
                         /HRManagerTest.java
                         /HRManagerTestSuite.java

org/jboss/example/service/util/AgeBasedSalaryTestCase.java
                              /LocationBasedSalaryTestVase.java
                              /SalaryStrategyTestSuite.java</programlisting>
        <para>The HRManagerTest class extends MicrocontainerTest in order to set up a number of employees to use as the basis for the tests.  Individual test cases then subclass this to perform the actual work. You can also see a couple of TestSuite classes that are used to group individual test cases together for convenience.</para>
        <para>To run the tests simply enter <code>mvn test</code> from the <code>humanResourcesService/</code> directory. You should see some DEBUG log output which shows  JBoss Microcontainer booting up and deploying beans from the relevant XML file before running each test. At the end of the test it then undeploys the beans and shuts down the microcontainer.</para>
        <note>
          <para>Some of the tests such as HRManagerTestCase, AgeBasedSalaryTestCase and LocationBasedSalaryTestCase simply unit test individual POJOs whilst other tests such as HRManagerAgeBasedTestCase and HRManagerLocationBasedTestCase unit test the whole service  consisting of multiple POJOs wired together. Either way the method for conducting the tests remains the same. Thanks to the MicrocontainerTest class it is trivial to set up and conduct comprehensive tests for any part of your code.</para>
          <para>Finally note that we didn&apos;t unit test the Address or Employee classes here. They were deliberately left out as they only contain trivial logic which is very unlikely to break.</para>
        </note>
      </section>
      <section>
        <title>Packaging a service</title>
        <para>Now that we have successfully created and tested our service it is time to package it up so that others can use it. The simplest way to do this is to create a JAR containing all of the classes. You can  choose to  include the  deployment descriptor if there is a sensible default way to configure the service but you are not required to do so.</para>
        <para>If you do choose to include the deployment descriptor then by convention you should call it <code>jboss-beans.xml</code> and put it in a META-INF directory. This helps if you want to later deploy the service in JBoss AS 5 as the  JAR deployer recognises this layout by default and will automatically perform the deployment.</para>
        <para>In our case we will not include it as we want to configure the service by editing the descriptor directly as a separate file. To generate a JAR in the <code>target</code> directory containing all of the compiled classes simply enter <code>mvn package</code> from the <code>humanResourcesService/</code> directory. </para>
        <para>To make the JAR available to other maven projects you then need to enter <code>mvn install</code> in order to copy it to your local maven repository.</para>
        <para>The final layout of the JAR is as follows:</para>
        <programlisting>org/jboss/example/service/Address.class
                         /Employee.class
                         /HRManager.class
org/jboss/example/service/util/AgeBasedSalaryStrategy.class
                              /LocationBasedSalaryStrategy.class
                              /SalaryStrategy.class
META-INF/MANIFEST.MF
META-INF/maven/org.jboss.microcontainer.examples/humanResourcesService/pom.xml
                                                                      /pom.properties</programlisting>
        <para>The META-INF/maven directory is automatically produced by maven and is required so that other maven projects can use this JAR as a dependency. If you are not using maven as your build system then you will not have this directory.</para>
      </section>
    </chapter>
    <chapter>
      <title>Using services </title>
      <para>In the previous chapter we looked at how to create, configure, test and package a service. It is now time to move on and create a client so that we can use the service to perform actual work.</para>
      <para>In order to keep things simple the client uses a Text User Interface (TUI) to accept input from the user and output results. In the real-world  a Graphical User Interface (GUI) would almost certainly be used but here we are more concerned with demonstrating how the client interacts with the service than showing how to develop a rich desktop application.</para>
      <para>You will find all of the necessary files in the <code>examples/User_Guide/gettingstarted/commandLineClient</code> directory.  As with the previous example this follows the Maven Standard Directory Layout: </para>
      <programlisting>commandLineClient/pom.xml
                 /src/main/assembly
                     /main/config
                     /main/java
                     /main/resources
                     /test/java
                     /test/resources</programlisting>
      <para>The client consists of 3 classes and 1 interface, located in the <code>src/main/java</code> directory:</para>
      <programlisting>org/jboss/example/client/Client.java
                        /ConsoleInput.java
                        /EmbeddedBootstrap.java
                        /UserInterface.java</programlisting>
      <para>UserInterface describes methods that the client will call at runtime to request data from the user. ConsoleInput is an  implementation of this  that creates a TUI allowing the user to operate the client from the command line. The advantage of this design is that we can easily create a Swing implementation of UserInterface  at a later date and replace the TUI with a GUI if we decide to improve usability. We can also create a mock implementation for testing purposes that simulates a user entering data. This allows us to check the behaviour of the client automatically using conventional JUnit test cases as demonstrated by the code in the <code>src/test/java</code> directory:</para>
      <programlisting>org/jboss/example/client/ClientTestCase.java
                        /ClientTestSuite.java
                        /MockUserInterface.java</programlisting>
      <para>To compile the source code, run the unit tests, build a client JAR  and assemble a distribution containing all of the necessary files simply type <code>mvn package</code> from the <code>commandLineClient</code> directory.   </para>
      <warning>
        <para>For the build to work you must first have built and installed  auditAspect.jar from the  <code>examples/User_Guide/gettingStarted/auditAspect</code> directory using the <code>mvn install</code> command. This is because we actually create a number of different  client distributions including one based on  AOP which relies on auditAspect.jar being available in the local maven repositiory.</para>
        <para>If you previously typed <code>mvn install</code> from the <code>examples/User_Guide/gettingStarted</code> directory then you will have already built and installed   humanResourcesService.jar together with  auditAspect.jar and the client will have already been packaged so this step will not be necessary.</para>
      </warning>
      <para>Once you have successfully compiled and packaged the client you will find the following subdirectories  in the <code>commandLineClient/target</code> directory:</para>
      <itemizedlist>
        <listitem>
          <para>client-pojo.dir - used to call the service without any AOP</para>
        </listitem>
        <listitem>
          <para>client-cl.dir - used to demonstrate classloading features</para>
        </listitem>
        <listitem>
          <para>client-aop.dir - used in Chapter 5. Adding behaviour through AOP</para>
        </listitem>
      </itemizedlist>
      <para>Each of these represents a different distribution containing all of the shell scripts, JARs,  and XML deployment descriptors that we need to run the client in different configurations. For the moment we will use the client-pojo distribution which can be found in the client-pojo.dir subdirectory:</para>
      <programlisting>run.sh
client-1.0.0.jar
jboss-beans.xml
lib/concurrent-1.3.4.jar
   /humanResourcesService-1.0.0.jar
   /jboss-common-core-2.0.4.GA.jar
   /jboss-common-core-2.2.1.GA.jar
   /jboss-common-logging-log4j-2.0.4.GA.jar
   /jboss-common-logging-spi-2.0.4.GA.jar
   /jboss-container-2.0.0.Beta6.jar
   /jboss-dependency-2.0.0.Beta6.jar
   /jboss-kernel-2.0.0.Beta6.jar
   /jbossxb-2.0.0.CR4.jar
   /log4j-1.2.14.jar
   /xercesImpl-2.7.1.jar</programlisting>
      <para>To run the client simply <code>cd</code> into client-pojo.dir and type <code>./run.sh</code>. You will then be presented with the following menu of options:  </para>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="images/tuiMenu.png"/>
        </imageobject>
      </mediaobject>
      <para>To select an option enter the  letter shown on the left-hand side and press return. For example to redisplay the menu options enter &apos;m&apos; followed by return. This is useful  if they scroll off the top of the screen as you input data and read results. Entering more than one letter or entering an invalid option will result in an appropriate error message.</para>
      <important>
        <para>The run.sh script sets up the runtime environment by  adding all of the JARs found in the <code>lib</code> directory to the  classpath using the <code>java.ext.dirs</code> system property. It also adds the current directory and the client-1.0.0.jar using the <code>-cp</code> flag so that the jboss-beans.xml deployment descriptor can be found at runtime together with the org.jboss.example.client.Client class which is called to start the application.</para>
      </important>
      <section>
        <title>Bootstrapping the microcontainer</title>
        <para>Before we use the client to deploy and call our service, lets take a closer look at what  happened during its construction:</para>
        <programlisting>public Client(final boolean useBus) throws Exception {
    this.useBus = useBus;

    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    url = cl.getResource(&quot;jboss-beans.xml&quot;);

    // Start JBoss Microcontainer
    bootstrap = new EmbeddedBootstrap();
    bootstrap.run();

    kernel = bootstrap.getKernel();
    controller = kernel.getController();
    bus = kernel.getBus();
 }</programlisting>
        <para>First of all a url representing the jboss-beans.xml deployment descriptor was created. This is required later on by the XML deployer so that we can deploy and undeploy beans declared in the file. Here we have chosen to use the getResource() method of the application classloader as we deliberately placed the jboss-beans.xml file  on the classpath.  However, this is not a requirement  and you are free to call the deployment descriptor anything you like and place it anywhere you want provided that the URL is valid and reachable.</para>
        <para>Next we created an instance of JBoss Microcontainer together with an XML deployer. This process  is called bootstrapping and for convenience a  BasicBootstrap class is provided  as part of the microcontainer to allow for configuration via system properties. To add an XML deployer we simply extend BasicBootstrap to create an EmbeddedBootstrap class  and override the protected bootstrap() method as follows:</para>
        <programlisting>public class EmbeddedBootstrap extends BasicBootstrap {

    protected BasicXMLDeployer deployer;

    public EmbeddedBootstrap() throws Exception {
        super();
    }

    public void bootstrap() throws Throwable {
        super.bootstrap();
        deployer = new BasicXMLDeployer(getKernel());
        Runtime.getRuntime().addShutdownHook(new Shutdown());
    }

    public void deploy(URL url) {
        ...
        deployer.deploy(url);
        ...
    }

    public void undeploy(URL url) {
        ...
        deployer.undeploy(url);
        ...
    }

    protected class Shutdown extends Thread {
        public void run() {
            log.info(&quot;Shutting down&quot;);
            deployer.shutdown();
        }
    }
}</programlisting>
        <para>The shutdown hook ensures that when the JVM is exited all of the beans are undeployed in the correct order. The public deploy/undeploy methods simply delegate to the BasicXMLDeployer so that we can deploy and undeploy beans declared in our jboss-beans.xml file.</para>
        <para>Finally we stored references to the microcontainer controller and bus so that we can lookup bean references by name and access them directly or indirectly as necessary.</para>
      </section>
      <section>
        <title>Deploying the service</title>
        <para>Once the client has been created we can proceed to deploy the Human Resources service. This is done by entering the &apos;d&apos; option. You should see the following log output indicating that the BasicXMLDeployer has parsed the jboss-beans.xml file using the url and instantiated the beans found within.</para>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/deployOutput.png"/>
          </imageobject>
        </mediaobject>
        <note>
          <para>The microcontainer is able to instantiate the beans as their classes are available in the extension classpath inside the <code>lib/humanResourcesService.jar</code> file. We could have equally placed these classes in an exploded directory structure and added this to the application classpath but in general you will package them in a JAR for convenience. </para>
        </note>
        <para>Notice that our deployment descriptor is entirely separate from the humanResourcesService.jar file. This is done on purpose so that you can easily edit it and test your changes by redeploying the service. The jboss-beans.xml file in the example contains some commented out fragments of XML that you can uncomment to configure it  in different ways:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

    &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
        &lt;!-- &lt;property name=&quot;hiringFreeze&quot;&gt;true&lt;/property&gt;
        &lt;property name=&quot;salaryStrategy&quot;&gt;&lt;inject bean=&quot;AgeBasedSalary&quot;/&gt;&lt;/property&gt; --&gt;
    &lt;/bean&gt;

    &lt;!-- &lt;bean name=&quot;AgeBasedSalary&quot; class=&quot;org.jboss.example.service.util.AgeBasedSalaryStrategy&quot;&gt;
        &lt;property name=&quot;minSalary&quot;&gt;1000&lt;/property&gt;
        &lt;property name=&quot;maxSalary&quot;&gt;80000&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;LocationBasedSalary&quot;
class=&quot;org.jboss.example.service.util.LocationBasedSalaryStrategy&quot;&gt;
        &lt;property name=&quot;minSalary&quot;&gt;2000&lt;/property&gt;
        &lt;property name=&quot;maxSalary&quot;&gt;90000&lt;/property&gt;
    &lt;/bean&gt; --&gt;

&lt;/deployment&gt;</programlisting>
        <important>
          <para>Depending on how you access the service at runtime you may need to shutdown the application and restart it again to  redeploy the service and see your changes. This reduces the flexibility of the application but  results in faster performance at runtime.  Alternatively you may be able to simply redeploy the service whilst the application is running. This increases  flexilibity but results in slower runtime performance. Careful consideration of these tradeoffs must   be made  before deciding on the approach you will take.</para>
        </important>
      </section>
      <section>
        <title>Direct access</title>
        <para>If no parameter is given to the <code>run.sh</code> script when  the client is started then a reference to the HRService bean is looked up using the microcontainer controller once the service is deployed:</para>
        <programlisting>private HRManager manager;
...
private final static String HRSERVICE = &quot;HRService&quot;;

...

void deploy() {
    bootstrap.deploy(url);
    if (!useBus &amp;&amp; manager == null) {
        ControllerContext context = controller.getInstalledContext(HRSERVICE);
        if (context != null) { manager = (HRManager) context.getTarget(); }
    }
}</programlisting>
        <para>Rather than immediately looking up a reference to the bean instance we first lookup a reference to a <code>ControllerContext</code>. We then obtain a reference to the bean instance from the context using the <code>getTarget()</code> method.  The reason for this is because the bean can exist in many states within the microcontainer e.g. NOT_INSTALLED, DESCRIBED, INSTANTIATED, CONFIGURED, INSTALLED. In order to keep track of which state the bean is in we need to wrap it in another object called a context that describes the current state. The name of the context is the same as the bean name. Once a context reaches the INSTALLED state then the bean it represents is considered to be deployed.</para>
        <para>Now that we have a reference to the bean instance representing our service entry point we can call methods on it to perform work:</para>
        <programlisting>@SuppressWarnings(&quot;unchecked&quot;)
Set&lt;Employee&gt; listEmployees() {
    if (useBus)
        ...
    else
        return manager.getEmployees();
}</programlisting>
        <para>The client is said to be accessing the service directly since it&apos;s using a reference to the actual bean instance.   Performance is good as each method call goes directly to the bean but  what happens if we want to reconfigure the service and redeploy it whilst the application is running? </para>
        <para>Reconfiguration as we know is achieved by making changes to the XML deployment descriptor and saving the file but in order to redeploy the service we must first undeploy the current one. During undeployment the microcontainer  controller releases its reference to the bean instance together with any beans that depend on it. The intention is that these beans will subsequently become available for garbage collection as they are no longer required by the application. Deploying the service again creates  new bean  instances representing the new configuration. Any subsequent lookups from clients will then retrieve references to these new instances and  they will be able to access the reconfigured service.</para>
        <para>The problem is that  we  cache the reference to the bean instance representing our service entry point in our client when we deploy the service for the first time. Undeploying the service therefore has no affect as the bean instance can still be accessed using the cached reference and it will not be garbage collected until the client releases it. Similarly deploying the service again will not cause another lookup as the client already has a cached reference. It will therefore continue to use the bean instance representing the initial service configuration.</para>
        <note>
          <para>You can test this behaviour for yourself by typing  &apos;u&apos; followed by return to undeploy the current service. You should still be able to access the service from the client even though it is &apos;undeployed&apos;. Now make some changes to the configuration using the jboss-beans.xml file and deploy it again using the &apos;d&apos; option (remember to save any changes you make to jboss-beans.xml first). Printing out the status of the service using the &apos;p&apos; option should allow you to see that the client is still accessing the initial instance of the service that was deployed.</para>
        </note>
        <warning>
          <para>Even if we change our client so that we lookup a new reference each time the service is redeployed there is nothing to prevent new developers from coming along and mistakedly handing out copies of this reference to other objects. If all of these references are not cleaned up during redeployment then this then puts us in the same situation as before with access to older instances of the service still possible.</para>
        </warning>
        <para>To reliably redeploy the reconfigured service you must therefore shutdown the application completely using the &apos;q&apos; option and restart it again using the <code>run.sh</code> script. For enterprise  services such as transactions, messaging and persistance this is perfectly acceptable since they are  generally always in use. As such they cannot be redeployed at runtime and benefit from the high performance given by using direct access. If your service falls into this category then you too should consider using direct access via the microcontainer controller.</para>
      </section>
      <section>
        <title>Indirect access</title>
        <para>The <code>run.sh</code> script can be called with an optional parameter &apos;bus&apos; to specify that calls to the Human Resources service should take place using the microcontainer bus:</para>
        <programlisting>./run.sh bus</programlisting>
        <para>Instead of using a direct reference to the bean instance obtained from the microcontainer controller we now call an invoke() method on the bus passing in the bean name, method name, method arguments and method types. The bus takes this information and uses it to call the bean on the client&apos;s behalf.</para>
        <programlisting>private final static String HRSERVICE = &quot;HRService&quot;;

...

@SuppressWarnings(&quot;unchecked&quot;)
Set&lt;Employee&gt; listEmployees() {
    if (useBus)
        return (Set&lt;Employee&gt;) invoke(HRSERVICE, &quot;getEmployees&quot;, new Object[] {}, new String[] {});
    else
        return manager.getEmployees();
}

private Object invoke(String serviceName, String methodName, Object[] args, String[] types) {
    Object result = null;
    try {
        result = bus.invoke(serviceName, methodName, args, types);
    } catch (Throwable t) {
        t.printStackTrace();
    }
    return result;
}</programlisting>
        <para>Behind the scenes the bus looks up the reference to the bean instance specified by the bean name and calls the chosen method using reflecton. Since the client never has a direct reference to the bean instance we say that it accesses the service &apos;indirectly&apos;. As the bus does not cache the reference we can  safely make changes to our service configuration and redeploy it at runtime. Subsequent calls by the client will then result in the new reference to the service being used as expected.   In technical terms we say that the client and service have been decoupled.</para>
        <note>
          <para>You can test this behaviour for yourself by deploying the service and using the &apos;p&apos; option to print out the status. Undeploy the service using the &apos;u&apos; option and check that you cannot access it anymore. Now make some changes to the configuration using the jboss-beans.xml file and deploy it again using the &apos;d&apos; option (remember to save any changes you make to jboss-beans.xml first). Printing out the status again using the &apos;p&apos; option should reveal that the client is accessing the new service configuration.</para>
        </note>
        <para>As the bus uses reflection to call bean instances it is slower than using direct access. The benefit however is that only the bus has references to the bean instances. This means that when a service is redeployed we can clean up all of the existing references and replace them with new ones, allowing us to reliably redeploy a service at runtime. Services that are not used very often or that are specific to certain applications are good candidates for indirect access using the microcontainer bus. This is either because the reduction in performance does not matter if the service is used rarely or the service can be deployed and undeployed together with the relevant applications to keep the runtime environment clean.</para>
      </section>
      <section>
        <title>Dynamic classloading</title>
        <para>So far we have been using the extension and application classloaders to load all of the classes in our application. The application classpath  was setup by the <code>run.sh</code> script using the -cp flag to include the current directory and the client-1.0.0.jar.</para>
        <programlisting>java -Djava.ext.dirs=`pwd`/lib -cp .:client-1.0.0.jar org.jboss.example.client.Client $1</programlisting>
        <para>For convenience the JARs in the lib directory were added to the extenion classloader&apos;s classpath  using the <code>java.ext.dirs</code> system property as this prevents us from having to list the full path to each of the JARs after the -cp flag. Since the extension classloader is the parent of the application classloader our client classes can find all of the microcontainer classes together with the Human Resources service classes at runtime.</para>
        <note>
          <para>If you are using Java 6+ then you can use a wildcard to include all JARs in a directory with the -cp flag.<programlisting>java -cp `pwd`/lib/*:.:client-1.0.0.jar org.jboss.example.client.Client $1</programlisting>This means that all of the classes in our application will be added to the application classloader&apos;s classpath and the extension classloader&apos;s classpath will retain its default value.</para>
        </note>
        <para>This is all well and good but what happens if we now want to deploy an additional service at runtime? If the new service is packaged in a JAR file then it needs to be visible to a classloader before any of its classes can be loaded.   The trouble is we have already setup the classpath for the application classloader (and extension classloader) on startup so we cannot easily add the url of the JAR. The same situation applies if the service classes are contained in a directory structure. Unless the top-level directory is located in the current directory (which is on the application classpath) then the classes will not be found by the application classloader.</para>
        <para>It&apos;s also possible that  we may wish to redeploy an existing service with changes to some of its classes. Since it is forbidden for an existing classloader to reload classes due to security constraints how can this be done?</para>
        <para>What we need is the ability to create a new classloader that knows the location of the new service&apos;s classes, or that can load new versions of an existing service&apos;s classes,  so that we can  deploy the service&apos;s beans. JBoss Microcontainer allows us to do this using the &lt;classloader&gt; element in the  deployment descriptor.</para>
        <para>The client-cl distribution in the <code>commandLineClient/target/client-cl.dir</code> directory contains the following files that demonstrate how this works: </para>
        <programlisting>run.sh
client-1.0.0.jar
jboss-beans.xml
lib/concurrent-1.3.4.jar
   /jboss-common-core-2.0.4.GA.jar
   /jboss-common-core-2.2.1.GA.jar
   /jboss-common-logging-log4j-2.0.4.GA.jar
   /jboss-common-logging-spi-2.0.4.GA.jar
   /jboss-container-2.0.0.Beta6.jar
   /jboss-dependency-2.0.0.Beta6.jar
   /jboss-kernel-2.0.0.Beta6.jar
   /jbossxb-2.0.0.CR4.jar
   /log4j-1.2.14.jar
   /xercesImpl-2.7.1.jar
otherLib/humanResourcesService-1.0.0.jar</programlisting>
        <para>As you can see the humanResourcesService.jar file has been moved to a new subdirectory called <code>otherLib</code>. In this location it is no longer available to either the extension or application classloaders whose classpaths are setup in the <code>run.sh</code> script:</para>
        <programlisting>java -Djava.ext.dirs=`pwd`/lib -cp .:client-1.0.0.jar org.jboss.example.client.Client $1</programlisting>
        <para>We must therefore create a new classloader during the deployment of the service so that we can load in the service classes and create instances of the beans. You can see how this is done by looking at the contents of the jboss-beans.xml file:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;            
                              xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
                              xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

  &lt;bean name=&quot;URL&quot; class=&quot;java.net.URL&quot;&gt;
    &lt;constructor&gt;
&lt;parameter&gt;file:/Users/newtonm/jbossmc/microcontainer/trunk/docs/examples/User_Guide/gettingStarted/commandLineClient/target/client-cl.dir/otherLib/humanResourcesService-1.0.0.jar&lt;/parameter&gt;
    &lt;/constructor&gt;
  &lt;/bean&gt;

  &lt;bean name=&quot;customCL&quot; class=&quot;java.net.URLClassLoader&quot;&gt;
    &lt;constructor&gt;
      &lt;parameter&gt;
        &lt;array&gt;
          &lt;inject bean=&quot;URL&quot;/&gt; 
        &lt;/array&gt;
      &lt;/parameter&gt;
    &lt;/constructor&gt;
  &lt;/bean&gt;

  &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
    &lt;classloader&gt;&lt;inject bean=&quot;customCL&quot;/&gt;&lt;/classloader&gt;
    &lt;!-- &lt;property name=&quot;hiringFreeze&quot;&gt;true&lt;/property&gt;
    &lt;property name=&quot;salaryStrategy&quot;&gt;&lt;inject bean=&quot;AgeBasedSalary&quot;/&gt;&lt;/property&gt; --&gt;
  &lt;/bean&gt;

   &lt;!-- &lt;bean name=&quot;AgeBasedSalary&quot; class=&quot;org.jboss.example.service.util.AgeBasedSalaryStrategy&quot;&gt;
    &lt;property name=&quot;minSalary&quot;&gt;1000&lt;/property&gt;
    &lt;property name=&quot;maxSalary&quot;&gt;80000&lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean name=&quot;LocationBasedSalary&quot; class=&quot;org.jboss.example.service.util.LocationBasedSalaryStrategy&quot;&gt;
    &lt;property name=&quot;minSalary&quot;&gt;2000&lt;/property&gt;
    &lt;property name=&quot;maxSalary&quot;&gt;90000&lt;/property&gt;
  &lt;/bean&gt; --&gt;

&lt;/deployment&gt;</programlisting>
        <para>First of all we create an instance of  java.net.URL called URL using  parameter injection in the constructor to specify the location of the humanResourcesService.jar file on our local filesystem. Then we create an instance of a URLClassLoader by  injecting the URL bean into the constructor as the only element in an array. Once this is done then we simply include a &lt;classloader&gt; element in our HRService bean definition and inject the customCL bean. This specifies that the HRManager class needs to be loaded by the customCL classloader.</para>
        <para>But how do we know which classloader to use for the other beans in the deployment?</para>
        <para>The answer is that by default all beans in the deployment use the current thread&apos;s context classloader. In our case the thread that handles deployment is the main thread of the application which has its context classloader set to the application classloader on startup. If you wish, you can choose to specify a different classloader for the entire deployment using a  &lt;classloader&gt; element as follows:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;            
                              xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
                              xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

  &lt;classloader&gt;&lt;inject bean=&quot;customCL&quot;/&gt;&lt;/classloader&gt;

  &lt;bean name=&quot;URL&quot; class=&quot;java.net.URL&quot;&gt;
    &lt;constructor&gt;
&lt;parameter&gt;file:/Users/newtonm/jbossmc/microcontainer/trunk/docs/examples/User_Guide/gettingStarted/commandLineClient/target/client-cl.dir/otherLib/humanResourcesService-1.0.0.jar&lt;/parameter&gt;
    &lt;/constructor&gt;
  &lt;/bean&gt;

  &lt;bean name=&quot;customCL&quot; class=&quot;java.net.URLClassLoader&quot;&gt;
    &lt;constructor&gt;
      &lt;parameter&gt;
        &lt;array&gt;
          &lt;inject bean=&quot;URL&quot;/&gt; 
        &lt;/array&gt;
      &lt;/parameter&gt;
    &lt;/constructor&gt;
  &lt;/bean&gt;

  ...

&lt;/deployment&gt;</programlisting>
        <para>This would be necessary for example if you wished to reconfigure the service by uncommenting the AgeBasedSalary or LocationBasedSalary beans. As you might expect, classloaders specified at the bean level override the deployment level classloader and if you wish to ignore the deployment level classloader altogether, and use the default thread context classloader for a bean, then you can use the &lt;null/&gt; value as follows:</para>
        <programlisting>  &lt;bean name=&quot;HRService&quot; class=&quot;org.jboss.example.service.HRManager&quot;&gt;
    &lt;classloader&gt;&lt;null/&gt;&lt;/classloader&gt;
  &lt;/bean&gt;</programlisting>
        <warning>
          <para>If you decide to create a new classloader for your service using the deployment descriptor then be aware that you may not be able to access classes loaded by it from the application classloader anymore. In our example this means that the client will no longer be able to cache a direct reference to the bean instance when using the microcontainer controller. You can see this for yourself by starting the client using the <code>run.sh</code> command and then trying to deploy the service. You should see that a java.lang.NoClassDefFoundError exception is thrown and the application will then exit.</para>
          <para>You must therefore use the bus to access the service indirectly and provide access to any classes shared by the client in the application classpath. In our example this means the Address, Employee, and SalaryStrategy classes.</para>
        </warning>
      </section>
    </chapter>
    <chapter>
      <title>Adding behaviour with AOP</title>
      <para>Object Oriented Programming (OOP) contains many useful techniques for software development including encapsulation, inheritance, and polymorphism but does not solve the problem of how to address logic that  is often repeated in many different classes. Examples of this include logging, security, and transactional logic  which is traditionally hard-coded into each class making the source code difficult to maintain. We call logic of this nature a  &apos;cross-cutting concern&apos; as it typically applies across class hierarchies.</para>
      <para>Aspect Oriented Programming (AOP) provides a  solution to this by allowing cross-cutting concerns to be applied to classes after they have been compiled. This keeps  the source code free of logic which is not central to the  main purpose of the class and aids maintenance. The way it is done varies depending on the AOP implementation. Typically if a class implements an interface then  all method calls to an instance of the class first pass through a proxy that implements the same interface and adds in the required behaviour. Alternatively, if an interface is not used, then  the java bytecode of the compiled class is modified so that the original methods  are renamed and replaced by methods that implement the cross-cutting logic. These  new methods  then call the original methods  after the cross-cutting logic has been executed. The same result can be achieved by modifying the bytecode to create a subclass of the original class that overrides its methods. The overriden methods then execute the cross-cutting logic before calling the corresponding methods of the super class. </para>
      <para>JBoss AOP is a framework for Aspect-Oriented Programming that allows you to create cross-cutting concerns using conventional java classes and methods. In AOP terminology each concern is represented by an aspect that you implement using a simple POJO. Behaviour is provided by methods within the aspect  called advices that follow certain rules for their parameter and return types together with any exceptions that they throw. Other than this you are free to use conventional object-oriented notions such as inheritance, encapsulation, and composition in order to make your cross-cutting concerns as maintainable as possible.  Aspects are applied to code using an expression language that allows you to specify which constructors, methods and even fields to target. This means that you can quickly change the behaviour of a number of classes simply by editing a configuration file. </para>
      <para>In this chapter we are going to look at using JBoss AOP together with the microcontainer to create and apply an auditing aspect to the Human Resources Service. We could choose to place auditing code within the  HRManager class but it would detract from the main purpose of the class and add unnecessary complexity. The design of the aspect will ensure that it can also be used with other classes if our requirements change at a later date.</para>
      <para>We shall also look at how AOP can be used to apply additional behaviour during the deployment phase. Specifically we will show how you can create and bind a proxy to a bean instance into a basic JNDI service so that you can access it using a JNDI lookup instead of the microcontainer controller.</para>
      <section>
        <title>Creating an aspect</title>
        <para>The <code>examples/User_Guide/gettingStarted/auditAspect</code> directory contains all the files you need to create the aspect.</para>
        <programlisting>auditAspect/pom.xml
           /src/main/java/org/jboss/example/aspect/AuditAspect.java</programlisting>
        <para>As you can see from the source code below all we need is a simple POJO.</para>
        <programlisting>public class AuditAspect {

    private String logDir;
    private BufferedWriter out;

    public AuditAspect() {
        logDir = System.getProperty(&quot;user.dir&quot;) + &quot;/log&quot;;

        File directory = new File(logDir);
        if (!directory.exists()) {
            directory.mkdir();
        }
    }

    public Object audit(ConstructorInvocation inv) throws Throwable {
        SimpleDateFormat formatter = new SimpleDateFormat(&quot;ddMMyyyy-kkmmss&quot;);
        Calendar now = Calendar.getInstance();
        String filename = &quot;auditLog-&quot; + formatter.format(now.getTime());

        File auditLog = new File(logDir + &quot;/&quot; + filename);
        auditLog.createNewFile();
        out = new BufferedWriter(new FileWriter(auditLog));
        return inv.invokeNext();
    }

    public Object audit(MethodInvocation inv) throws Throwable {
        String name = inv.getMethod().getName();
        Object[] args = inv.getArguments();
        Object retVal = inv.invokeNext();

        StringBuffer buffer = new StringBuffer();
        for (int i=0; i &lt; args.length; i++) {
            if (i &gt; 0) {
                buffer.append(&quot;, &quot;);
            }
            buffer.append(args[i].toString());
        }

        if (out != null) {
            out.write(&quot;Method: &quot; + name);
            if (buffer.length() &gt; 0) {
                out.write(&quot; Args: &quot; + buffer.toString());
            }
            if (retVal != null) {
                 out.write(&quot; Return: &quot; + retVal.toString());
            }
            out.write(&quot;\n&quot;);
            out.flush();
        }
        return retVal;
    }
}</programlisting>
        <para>The constructor checks for the presence of a <code>log</code> directory in the current working directory and creates one if not found. After this we define an advice that will be called whenever the constructor of our target class is called. The purpose of this is to create a new log file within the log directory so that we can record method calls made on different instances of our target class in separate files. Finally we define an advice that will apply to each method call made on the target class. Here we store the method name and arguments together with the return value so that we can construct an audit record and write it to the current log file. Notice how each advice calls <code>inv.invokeNext()</code>. This is required in order to call the  next advice, if more than one cross-cutting concern has been applied, or to call the target constructor/method.</para>
        <note>
          <para>Each advice is implemented using a method that takes an invocation object as a parameter, throws Throwable and returns  Object. This is necessary as we do not know at design time which constructors or methods  our advices will be applied to  so the types must be as generic as possible. For more information on creating aspects and advices together with additional examples of how to apply them to various classes please consult the JBoss AOP project documentation.</para>
        </note>
        <para>To compile the class and create an auditAspect.jar file that can be used by  other examples simply type <code>mvn install</code> from the auditAspect directory.</para>
      </section>
      <section>
        <title>Configuring the microcontainer</title>
        <para>Before we can apply the audit aspect to our service we must first add a number of JARs to the extension classpath. These can be found in the <code>lib</code> subdirectory of the  client-aop distribution located in the <code>examples/User_Guide/gettingStarted/commandLineClient/target/client-aop.dir</code> directory:</para>
        <programlisting>run.sh
client-1.0.0.jar
jboss-beans.xml
lib/<code>auditAspect-1.0.0.jar</code>
   /concurrent-1.3.4.jar
   /humanResourcesService-1.0.0.jar
   /<code>javassist-3.6.0.GA.jar</code>
   /<code>jboss-aop-2.0.0.beta1.jar</code>
   /<code>jboss-aop-mc-int-2.0.0.Beta6.jar</code>
   /jboss-common-core-2.0.4.GA.jar
   /jboss-common-core-2.2.1.GA.jar
   /jboss-common-logging-log4j-2.0.4.GA.jar
   /jboss-common-logging-spi-2.0.4.GA.jar
   /jboss-container-2.0.0.Beta6.jar
   /jboss-dependency-2.0.0.Beta6.jar
   /jboss-kernel-2.0.0.Beta6.jar
   /jbossxb-2.0.0.CR4.jar
   /log4j-1.2.14.jar
   /<code>trove-2.1.1.jar</code>
   /xercesImpl-2.7.1.jar</programlisting>
        <para>First of all we need to include the <code>auditAspect</code> jar  as we need to create an instance of our aspect at runtime in order to execute the logic.  We then need to include the jar file for JBoss AOP  (<code>jboss-aop</code>) together with its dependencies; <code>javassist</code> and <code>trove</code>.  Finally we need to add the<code> jboss-aop-mc-int</code> jar as this contains an XML schema definition that allows us to define aspects inside our XML deployment descriptor. It also contains integration code to create dependencies between normal beans and aspect beans within the microcontainer so that we can add behaviour during the deployment and undeployment phases.</para>
        <note>
          <para>Since we are using Maven2 to assemble the client-aop distribution we can easily add these JAR files by declaring the appropriate dependencies in our <code>pom.xml</code> file and creating a valid assembly descriptor. If you are using Ant to perform your build then you will need to do this in a different way.</para>
        </note>
      </section>
      <section>
        <title>Applying an aspect</title>
        <para>Now that we have a valid distribution containing everything we need we can configure our jboss-beans.xml file to apply the audit aspect. This can be found in the <code>examples/User_Guide/gettingStarted/commandLineClient/target/client-aop.dir</code> directory:</para>
        <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;deployment xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;urn:jboss:bean-deployer:2.0 bean-deployer_2_0.xsd&quot;
            xmlns=&quot;urn:jboss:bean-deployer:2.0&quot;&gt;

    &lt;bean name=&quot;AspectManager&quot; class=&quot;org.jboss.aop.AspectManager&quot;&gt;
        &lt;constructor factoryClass=&quot;org.jboss.aop.AspectManager&quot;
                             factoryMethod=&quot;instance&quot;/&gt;
    &lt;/bean&gt;

    &lt;aop:aspect xmlns:aop=&quot;urn:jboss:aop-beans:1.0&quot;
                       name=&quot;AuditAspect&quot; class=&quot;org.jboss.example.aspect.AuditAspect&quot;
                       method=&quot;audit&quot; pointcut=&quot;execution(public org.jboss.example.service.HRManager-&gt;new(..)) OR                                        execution(public * org.jboss.example.service.HRManager-&gt;*(..))&quot;&gt;
    &lt;/aop:aspect&gt;

    ...

&lt;/deployment&gt;</programlisting>
        <para>Before we can apply our aspect to any classes we need to create an instance of org.jboss.aop.AspectManager using a &lt;bean&gt; element. We use a factory method instead of calling a conventional constructor as we only want one instance of the AspectManager in the JVM at runtime i.e. it is a singleton.</para>
        <para>Next we create an instance of our aspect called AuditAspect using the &lt;aop:aspect&gt; element. This looks much like the &lt;bean&gt; element as it has <code>name</code> and <code>class</code> attributes that you can use in the same way.  However it also has <code>method</code> and <code>pointcut</code> attributes that you can use to apply or &apos;bind&apos;  an advice within the aspect to constructors and methods within other classes. We use these attributes to bind the audit advice to all public constructors and methods within the HRManager class. We only need to specify one method called audit as we have overloaded this method within our AuditAspect class with different parameters. JBoss AOP knows at runtime which one to select based on whether a constructor or method invocation is being made.</para>
        <para>This additional configuration is all we need to apply the audit aspect at runtime and add auditing behaviour to the Human Resources service. You can test this out for yourself by running the client using the <code>run.sh</code> script. A <code>log</code> directory will be created on startup alongside the <code>lib</code> directory as the AuditAspect bean is created by the microcontainer. Each deployment of the Human Resources service will then cause a new log file to appear within the <code>log</code> directory containing a record of any calls made from the client to the service:</para>
        <programlisting>log/auditLog-28112007-163902
   /auditLog-28112007-164055
   /auditLog-28112007-164108</programlisting>
        <para>The audit records inside the log files will look something like this:</para>
        <programlisting>Method: getEmployees Return: []
Method: addEmployee Args: (Santa Claus, 1 Reindeer Avenue, Lapland City - 25/12/1860) Return: true
Method: getSalary Args: (Santa Claus, null - Birth date unknown) Return: 10000
Method: getEmployees Return: [(Santa Claus, 1 Reindeer Avenue, Lapland City - 25/12/1860)]
Method: isHiringFreeze Return: false
Method: getEmployees Return: [(Santa Claus, 1 Reindeer Avenue, Lapland City - 25/12/1860)]
Method: getSalaryStrategy</programlisting>
        <para>If you wish to remove the auditing behaviour then you can simply comment out the relevant fragments of XML in the deployment descriptor and restart the application.</para>
        <warning>
          <para>The order of deployment for aspects declared in this way relative to normal beans matters in the deployment descriptor. Specifically each aspect must be declared before the beans that it applies to so that the microcontainer deploys them in that order. This is because the microcontainer may need to alter the bytecode of the normal bean class in order to add the cross-cutting logic before it creates an instance and stores a  reference to it in the controller. If a normal bean instance has already been created then this is not possible. </para>
        </warning>
      </section>
      <section>
        <title>Lifecycle callbacks</title>
        <para>In addition to applying aspects to beans that we instantiate using the microcontainer we can also add behaviour during the deployment and undeployment process. As you may recall from the Direct access section of Chapter 4, a bean goes through several different states as it is deployed. These include:<itemizedlist>
            <listitem>
              <para>NOT_INSTALLED - the deployment descriptor containing the bean has been parsed along with any annotations on the bean itself.</para>
            </listitem>
            <listitem>
              <para>DESCRIBED - any dependencies created by AOP have been added to the bean and custom annotations have been processed.</para>
            </listitem>
            <listitem>
              <para>INSTANTIATED - an instance of the bean has been created.</para>
            </listitem>
            <listitem>
              <para>CONFIGURED - properties have been injected into the bean along with any references to other beans.</para>
            </listitem>
            <listitem>
              <para>CREATE - the create method, if defined on the bean,  has been called.</para>
            </listitem>
            <listitem>
              <para>START - the start method, if defined on the bean, has been called.</para>
            </listitem>
            <listitem>
              <para>INSTALLED - any custom install actions that were defined in the deployment descriptor have been executed and the bean is ready to access.</para>
            </listitem>
          </itemizedlist></para>
        <important>
          <para>The CREATE and START states are included in order to allow services that used to be implemented as MBeans in JBoss AS 3.x and 4.x to function correctly when implemented as beans in JBoss AS 5.x. If you do not define any corresponding create/start methods in your bean then it will simply pass straight through these states.</para>
        </important>
        <para>Together these states represent the bean&apos;s lifecycle and using an additional set of &lt;aop&gt; elements you can define a number of callbacks to be applied to any point:</para>
        <programlisting>&lt;aop:lifecycle-describe&gt; - applied when entering/leaving the DESCRIBED state
&lt;aop:lifecycle-instantiate&gt; - applied when entering/leaving the INSTANTIATED state
&lt;aop:lifecycle-configure&gt; - applied when entering/leaving the CONFIGURED state
&lt;aop:lifecycle-create&gt; - applied when entering/leaving the CREATE state
&lt;aop:lifecycle-start&gt; - applied when entering/leaving the START state
&lt;aop:lifecycle-install&gt; - applied when entering/leaving the INSTALLED state</programlisting>
        <para>Just like the &lt;bean&gt; element and the &lt;aop:aspect&gt; element the &lt;aop:lifecycle-&gt; elements contain <code>name</code> and <code>class</code> attributes. These allow the microcontainer to create an instance of the callback class and give it a name so that it can be used as beans enter/leave the relevant state during deployment and undeployment. You can specify which beans are affected by the callback using the <code>classes</code> attribute:</para>
        <programlisting>&lt;aop:lifecycle-install xmlns:aop=&quot;urn:jboss:aop-beans:1.0&quot;
    name=&quot;InstallAdvice&quot;
    class=&quot;org.jboss.test.microcontainer.support.LifecycleCallback&quot;
    classes=&quot;@org.jboss.test.microcontainer.support.Install&quot;&gt;
&lt;/aop:lifecycle-install&gt;</programlisting>
        <para>Here we have specified that additional logic in the LifecycleCallback class should be applied  to any bean classes that are annotated with @org.jboss.test.microcontainer.support.Install before they enter and after they leave the INSTALLED state. </para>
        <para>In order for the callback class to work it must contain <code>install</code> and <code>uninstall</code> methods  that take ControllerContext as a parameter:</para>
        <programlisting>import org.jboss.dependency.spi.ControllerContext;

public class LifecycleCallback {

    public void install(ControllerContext ctx) {
        System.out.println(&quot;Bean &quot; + ctx.getName() + &quot; is being installed&quot;;
    }

    public void uninstall(ControllerContext ctx) {
        System.out.println(&quot;Bean &quot; + ctx.getName() + &quot; is being uninstalled&quot;;
    }
} </programlisting>
        <para>The install method will be called during the bean&apos;s deployment and the uninstall method during its undeployment.</para>
        <note>
          <para>Although we are adding behaviour to the deployment and undeployment process using callbacks we are not actually using AOP to achieve this. The reason we have included them in this section, and the reason why they are part of the aop XML schema, is that they use the pointcut expression functionality of JBoss AOP to determine which bean classes they should apply to. We have already shown how the <code>classes</code> attribute allows you to write a shorthand pointcut expression to target annotated bean classes. Later in Part III - AOP Development we will show how it is possible to use regular pointcut expressions to target classes in a much more powerful way.</para>
        </note>
      </section>
      <section>
        <title>Adding service lookup through JNDI</title>
        <para/>
      </section>
    </chapter>
    <chapter>
      <title>Advanced deployment</title>
      <para>Mention the need for a main deployer and explain how we add various deployers to this.</para>
      <section>
        <title>Aspectized deployers </title>
        <para>Give example of using aspectized bean deployer and show how it&apos;s the same as the BasicXMLDeployer.</para>
      </section>
      <section>
        <title>Changing the package structure</title>
        <para>Give an example where we move the jboss-beans.xml file out of the META-INF directory and change the location of the classes.</para>
      </section>
      <section>
        <title>Changing the XML file format</title>
        <para>Give an example of changing the jboss-beans.xml file for a jboss-beans.properties file.</para>
      </section>
      <section>
        <title>Changing the classloading strategy</title>
        <para/>
      </section>
      <section>
        <title>Adding a deployment stage</title>
        <para/>
      </section>
    </chapter>
  </part>
  <part>
    <title>POJO Development</title>
  </part>
  <part>
    <title>AOP Development</title>
  </part>
  <part>
    <title>Extending the Microcontainer</title>
    <chapter>
      <title>Guice Extensions </title>
    </chapter>
    <chapter>
      <title>OSGi Extensions</title>
    </chapter>
    <chapter>
      <title>Drools Extensions</title>
    </chapter>
    <chapter>
      <title>jBPM Extensions</title>
    </chapter>
  </part>
  <part>
    <title>Integrating the Microcontainer</title>
    <chapter>
      <title>JBoss AS</title>
      <section>
        <title>Bootstrapping the microcontainer</title>
      </section>
      <section>
        <title>Java EE Deployers</title>
      </section>
      <section>
        <title>Classloading</title>
        <para>Explain that the default classloading goes to the unified repository.</para>
      </section>
      <section>
        <title>MBean Compatibility</title>
      </section>
      <section>
        <title>Managing POJOs</title>
      </section>
    </chapter>
  </part>
  <appendix>
    <title>Additional Resources</title>
    <section>
      <title>Wiki</title>
    </section>
    <section>
      <title>Forums</title>
    </section>
  </appendix>
</book>
