 options {
   LOOKAHEAD=2;
   DEBUG_PARSER=true;
   DEBUG_LOOKAHEAD=true;
   DEBUG_TOKEN_MANAGER=false;
   STATIC=false;
}

PARSER_BEGIN(HeaderValue)
package org.jboss.osgi.plugins.metadata;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jboss.osgi.spi.metadata.*;

/**
 * A JavaCC 3.2 grammar for the OSGi R4 bundle headers
 *
 * @author Scott.Stark@jboss.org
 * @author Ales.Justin@jboss.org
 */
public class HeaderValue
{
   public HeaderValue()
   {
      this(new StringReader(""));
   }

   public HeaderValue(String value)
   {
      this(new StringReader(value));
   }

   private void applyTracing(boolean trace)
   {
      if (trace)
      {
         enable_tracing();
      }
      else
      {
         disable_tracing();
      }
   }

   private void addParameter(Map<String, Parameter> parameters, String key, String value)
   {
      Parameter parameter = parameters.get(key);
      if (parameter == null)
      {
         parameter = new AbstractParameter();
         parameters.put(key, parameter);
      }
      parameter.addValue(value);
   }

   public void parsePackages(List<PackageAttribute> list, boolean trace)
      throws ParseException
   {
      // This will have no effect unless the debugging options are true
      applyTracing(trace);
      parsePackages(list);
   }

   public void parseParameters(List<ParameterizedAttribute> list, boolean trace)
      throws ParseException
   {
      // This will have no effect unless the debugging options are true
      applyTracing(trace);
      parseParameters(list);
   }

   public void parsePaths(List<ParameterizedAttribute> list, boolean trace)
      throws ParseException
   {
      // This will have no effect unless the debugging options are true
      applyTracing(trace);
      parsePaths(list);
   }

   public static void parsePackages(String header, List<PackageAttribute> list, boolean trace)
      throws ParseException
   {
      HeaderValue parser = new HeaderValue(header);
      parser.parsePackages(list, trace);
   }

   public static void parseParameters(String header, List<ParameterizedAttribute> list, boolean trace)
      throws ParseException
   {
      HeaderValue parser = new HeaderValue(header);
      parser.parseParameters(list, trace);
   }

   public static void parsePaths(String header, List<ParameterizedAttribute> list, boolean trace)
      throws ParseException
   {
      HeaderValue parser = new HeaderValue(header);
      parser.parsePaths(list, trace);
   }
}
PARSER_END(HeaderValue)

/* IGNORE WHITESPACE */

SKIP :
{
    " "
  | "\r"
  | "\t"
  | "\n"
}

/* Common tokens */
TOKEN:
{
  <#ALPHA: [ "a"-"z", "A"-"Z" ] >
|
  <#DIGIT: ["0" - "9"] >
|
  <STAR: "*" >
|
  <NUMBER: (<DIGIT>)+ >
|
  <DECIMAL_NUMBER: <NUMBER> ( "." <NUMBER> )? >
|
  <#ALPHANUM: <ALPHA>|<DECIMAL_NUMBER> >
|
  <VERSION_VALUE: (<NUMBER> ("." <NUMBER> ("." <NUMBER> ("." <ALPHANUM>)? )?  )?) >
|
  <#TOKN: (<ALPHANUM>|<VERSION_VALUE>|"_"|"-")+ >
|
  <#JLETTER: [ "_", "a"-"z", "A"-"Z" ] >
|
  <#JLETTER_OR_DIGIT: <JLETTER> | <DIGIT> >
|
  <QNAME: <JLETTER> (<JLETTER_OR_DIGIT>)* ("." <JLETTER> (<JLETTER_OR_DIGIT>)*)* (".*")? >
|
  <QUOTED_STRING: "\"" ( ~["\"", "\\", "\r", "\n", "\u0000"] | "\\\"")* "\"" >
|
  <#ARGUMENT: <TOKN>|<QUOTED_STRING> >
|
  <ATTRIBUTE: <TOKN> "=" <ARGUMENT> >
|
  <DIRECTIVE: <TOKN> ":=" <ARGUMENT> >
|
  <PATH_ELEMENT: (~["/", "\"", "\n", "\r", "\u0000", ";", ","])+ >
|
  <PATH_SEP: "/" >
|
  <#PATH_UNQUOTED: <PATH_SEP> | (<PATH_SEP>)? <PATH_ELEMENT> (<PATH_SEP> <PATH_ELEMENT>)* >
|
  <PATH: <PATH_UNQUOTED> | "\"" <PATH_UNQUOTED> "\"" >
}

/** Start of the grammar */
/** Entry point for the Import-Package header value parsing. */

void parsePackages(List<PackageAttribute> list) :
{
}
{
  packageInfo(list) ( "," packageInfo(list) )*
  {
  }
}

void parseParameters(List<ParameterizedAttribute> list) :
{
}
{
  parameterInfo(list) ( "," parameterInfo(list) )*
  {
  }
}

void parsePaths(List<ParameterizedAttribute> list) :
{
}
{
  pathInfo(list) ( "," pathInfo(list) )*
  {
  }
}

void packageInfo(List<PackageAttribute> list) :
{
   List<String> packages = new ArrayList<String>();
   Map<String, Parameter> parameters = new HashMap<String, Parameter>();
}
{
   packageNames(packages) ( ";" parsePackageParameters(parameters) )*
   {
      for(String pckg : packages)
      {
         list.add(new AbstractPackageAttribute(pckg, parameters));
      }
   }
}

void pathInfo(List<ParameterizedAttribute> list) :
{
   List<String> paths = new ArrayList<String>();
   Map<String, Parameter> parameters = new HashMap<String, Parameter>();
}
{
   pathNames(paths) ( ";" parsePathParameters(parameters) )+
   {
      for(String path : paths)
      {
         list.add(new AbstractPackageAttribute(path, parameters));
      }
   }
}

void parameterInfo(List<ParameterizedAttribute> list) :
{
   Token t;
   Map<String, Parameter> parameters = new HashMap<String, Parameter>();
}
{
   t = <QNAME> ( ";" parseAttributeParameters(parameters) )*
   {
      list.add(new AbstractParameterizedAttribute(t.toString(), parameters));
   }
}

void packageNames(List<String> packages) :
{
	Token t;
}
{
  t=<QNAME> {packages.add(t.image);} ( ";" packageNames(packages))*
  |
  t=<STAR> {packages.add(t.image);} ( ";" packageNames(packages))*
}

void pathNames(List<String> paths) :
{
	Token t;
}
{
  t=<PATH> {paths.add(t.image);} ( ";" pathNames(paths))*
}

void parsePackageParameters(Map<String, Parameter> parameters) :
{
   Token t;
}
{
   t = <DIRECTIVE>
   {
      String ts = t.toString();
      String[] params = ts.split(":=");
      addParameter(parameters, params[0], params[1]);
   }
|
   t = <ATTRIBUTE>
   {
      String ts = t.toString();
      String[] params = ts.split("=");
      addParameter(parameters, params[0], params[1]);
   }
   ( ";" parsePackageParameters(parameters))*
}

void parseAttributeParameters(Map<String, Parameter> parameters) :
{
   Token t;
}
{
   t = <DIRECTIVE>
   {
      String ts = t.toString();
      String[] params = ts.split(":=");
      addParameter(parameters, params[0], params[1]);
   }
|
   t = <ATTRIBUTE>
   {
      String ts = t.toString();
      String[] params = ts.split("=");
      addParameter(parameters, params[0], params[1]);
   }
   ( ";" parseAttributeParameters(parameters))*
}

void parsePathParameters(Map<String, Parameter> parameters) :
{
   Token t;
}
{
   t = <DIRECTIVE>
   {
      String ts = t.toString();
      String[] params = ts.split(":=");
      addParameter(parameters, params[0], params[1]);
   }
|
   t = <ATTRIBUTE>
   {
      String ts = t.toString();
      String[] params = ts.split("=");
      addParameter(parameters, params[0], params[1]);
   }
   ( ";" parsePathParameters(parameters))*
}

